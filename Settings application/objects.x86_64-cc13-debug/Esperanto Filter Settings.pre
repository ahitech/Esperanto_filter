






extern const unsigned char B_HAND_CURSOR[];
extern const unsigned char B_I_BEAM_CURSOR[];



class BCursor;
extern const BCursor *B_CURSOR_SYSTEM_DEFAULT;
extern const BCursor *B_CURSOR_I_BEAM;




enum system_message_code {
 B_ABOUT_REQUESTED = '_ABR',
 B_WINDOW_ACTIVATED = '_ACT',
 B_APP_ACTIVATED = '_ACT',
 B_ARGV_RECEIVED = '_ARG',
 B_QUIT_REQUESTED = '_QRQ',
 B_CLOSE_REQUESTED = '_QRQ',
 B_CANCEL = '_CNC',
 B_INVALIDATE = '_IVL',
 B_KEY_DOWN = '_KYD',
 B_KEY_UP = '_KYU',
 B_UNMAPPED_KEY_DOWN = '_UKD',
 B_UNMAPPED_KEY_UP = '_UKU',
 B_KEY_MAP_LOADED = '_KML',
 B_LAYOUT_WINDOW = '_LAY',
 B_MODIFIERS_CHANGED = '_MCH',
 B_MINIMIZE = '_WMN',
 B_MOUSE_DOWN = '_MDN',
 B_MOUSE_MOVED = '_MMV',
 B_MOUSE_ENTER_EXIT = '_MEX',
 B_MOUSE_IDLE = '_MSI',
 B_MOUSE_UP = '_MUP',
 B_MOUSE_WHEEL_CHANGED = '_MWC',
 B_OPEN_IN_WORKSPACE = '_OWS',
 B_PACKAGE_UPDATE = '_PKU',
 B_PRINTER_CHANGED = '_PCH',
 B_PULSE = '_PUL',
 B_READY_TO_RUN = '_RTR',
 B_REFS_RECEIVED = '_RRC',
 B_RELEASE_OVERLAY_LOCK = '_ROV',
 B_ACQUIRE_OVERLAY_LOCK = '_AOV',
 B_SCREEN_CHANGED = '_SCH',
 B_VALUE_CHANGED = '_VCH',
 B_TRANSLATOR_ADDED = '_ART',
 B_TRANSLATOR_REMOVED = '_RRT',
 B_DELETE_TRANSLATOR = '_DRT',
 B_VIEW_MOVED = '_VMV',
 B_VIEW_RESIZED = '_VRS',
 B_WINDOW_MOVED = '_WMV',
 B_WINDOW_RESIZED = '_WRS',
 B_WORKSPACES_CHANGED = '_WCG',
 B_WORKSPACE_ACTIVATED = '_WAC',
 B_ZOOM = '_WZM',
 B_COLORS_UPDATED = '_CLU',
 B_FONTS_UPDATED = '_FNU',
 B_TRACKER_ADDON_MESSAGE = '_TAM',
 _APP_MENU_ = '_AMN',
 _BROWSER_MENUS_ = '_BRM',
 _MENU_EVENT_ = '_MEV',
 _PING_ = '_PBL',
 _QUIT_ = '_QIT',
 _VOLUME_MOUNTED_ = '_NVL',
 _VOLUME_UNMOUNTED_ = '_VRM',
 _MESSAGE_DROPPED_ = '_MDP',
 _DISPOSE_DRAG_ = '_DPD',
 _MENUS_DONE_ = '_MND',
 _SHOW_DRAG_HANDLES_ = '_SDH',
 _EVENTS_PENDING_ = '_EVP',
 _UPDATE_ = '_UPD',
 _UPDATE_IF_NEEDED_ = '_UPN',
 _PRINTER_INFO_ = '_PIN',
 _SETUP_PRINTER_ = '_SUP',
 _SELECT_PRINTER_ = '_PSL'

};



enum command_code {
 B_SET_PROPERTY = 'PSET',
 B_GET_PROPERTY = 'PGET',
 B_CREATE_PROPERTY = 'PCRT',
 B_DELETE_PROPERTY = 'PDEL',
 B_COUNT_PROPERTIES = 'PCNT',
 B_EXECUTE_PROPERTY = 'PEXE',
 B_GET_SUPPORTED_SUITES = 'SUIT',
 B_UNDO = 'UNDO',
 B_REDO = 'REDO',
 B_CUT = 'CCUT',
 B_COPY = 'COPY',
 B_PASTE = 'PSTE',
 B_SELECT_ALL = 'SALL',
 B_SAVE_REQUESTED = 'SAVE',
 B_MESSAGE_NOT_UNDERSTOOD = 'MNOT',
 B_NO_REPLY = 'NONE',
 B_REPLY = 'RPLY',
 B_SIMPLE_DATA = 'DATA',
 B_MIME_DATA = 'MIME',
 B_ARCHIVED_OBJECT = 'ARCV',
 B_UPDATE_STATUS_BAR = 'SBUP',
 B_RESET_STATUS_BAR = 'SBRS',
 B_NODE_MONITOR = 'NDMN',
 B_QUERY_UPDATE = 'QUPD',
 B_ENDORSABLE = 'ENDO',
 B_COPY_TARGET = 'DDCP',
 B_MOVE_TARGET = 'DDMV',
 B_TRASH_TARGET = 'DDRM',
 B_LINK_TARGET = 'DDLN',
 B_INPUT_DEVICES_CHANGED = 'IDCH',
 B_INPUT_METHOD_EVENT = 'IMEV',
 B_WINDOW_MOVE_TO = 'WDMT',
 B_WINDOW_MOVE_BY = 'WDMB',
 B_SILENT_RELAUNCH = 'AREL',
 B_OBSERVER_NOTICE_CHANGE = 'NTCH',
 B_CONTROL_INVOKED = 'CIVK',
 B_CONTROL_MODIFIED = 'CMOD'


};
typedef signed char __haiku_std_int8;
typedef unsigned char __haiku_std_uint8;
typedef signed short __haiku_std_int16;
typedef unsigned short __haiku_std_uint16;
typedef signed int __haiku_std_int32;
typedef unsigned int __haiku_std_uint32;

typedef signed long __haiku_std_int64;
typedef unsigned long __haiku_std_uint64;





typedef __haiku_std_int8 __haiku_int8;
typedef __haiku_std_uint8 __haiku_uint8;
typedef __haiku_std_int16 __haiku_int16;
typedef __haiku_std_uint16 __haiku_uint16;




typedef __haiku_std_int32 __haiku_int32;
typedef __haiku_std_uint32 __haiku_uint32;

typedef __haiku_std_int64 __haiku_int64;
typedef __haiku_std_uint64 __haiku_uint64;


typedef signed long int __haiku_saddr_t;
typedef unsigned long int __haiku_addr_t;


 typedef __haiku_int64 __haiku_phys_saddr_t;
 typedef __haiku_uint64 __haiku_phys_addr_t;
 typedef __haiku_addr_t __haiku_generic_addr_t;


extern "C" {


int _to_positive_error(int error);
int _to_negative_error(int error);


}

typedef __haiku_std_int8 int8_t;
typedef __haiku_std_uint8 uint8_t;

typedef __haiku_std_int16 int16_t;
typedef __haiku_std_uint16 uint16_t;

typedef __haiku_std_int32 int32_t;
typedef __haiku_std_uint32 uint32_t;

typedef __haiku_std_int64 int64_t;
typedef __haiku_std_uint64 uint64_t;


typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;


typedef int32_t int_fast8_t;
typedef uint32_t uint_fast8_t;

typedef int32_t int_fast16_t;
typedef uint32_t uint_fast16_t;

typedef int32_t int_fast32_t;
typedef uint32_t uint_fast32_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef __haiku_saddr_t intptr_t;
typedef __haiku_addr_t uintptr_t;


typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;
extern "C" {


extern intmax_t imaxabs(intmax_t num);
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

extern intmax_t strtoimax(const char *string, char **_end, int base);
extern uintmax_t strtoumax(const char *string, char **_end, int base);




}
typedef unsigned long u_long;
typedef unsigned int u_int;
typedef unsigned short u_short;
typedef unsigned char u_char;



typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned char unchar;


typedef __haiku_int64 blkcnt_t;
typedef __haiku_std_int32 blksize_t;
typedef __haiku_int64 fsblkcnt_t;
typedef __haiku_int64 fsfilcnt_t;
typedef __haiku_int64 off_t;
typedef __haiku_int64 ino_t;
typedef __haiku_std_int32 cnt_t;
typedef __haiku_int32 dev_t;
typedef __haiku_int32 pid_t;
typedef __haiku_int32 id_t;

typedef __haiku_std_uint32 uid_t;
typedef __haiku_std_uint32 gid_t;
typedef __haiku_std_uint32 mode_t;
typedef __haiku_std_uint32 umode_t;
typedef __haiku_std_int32 nlink_t;




 typedef off_t daddr_t;

typedef char* caddr_t;

typedef __haiku_addr_t addr_t;
typedef __haiku_int32 key_t;

typedef __haiku_std_int32 clockid_t;
typedef struct __timer_t* timer_t;




typedef struct _pthread_thread *pthread_t;
typedef struct _pthread_attr *pthread_attr_t;
typedef struct _pthread_barrier pthread_barrier_t;
typedef struct _pthread_barrierattr *pthread_barrierattr_t;
typedef struct _pthread_mutex pthread_mutex_t;
typedef struct _pthread_mutexattr *pthread_mutexattr_t;
typedef struct _pthread_cond pthread_cond_t;
typedef struct _pthread_condattr *pthread_condattr_t;
typedef int pthread_key_t;
typedef struct _pthread_once pthread_once_t;
typedef struct _pthread_rwlock pthread_rwlock_t;
typedef struct _pthread_rwlockattr *pthread_rwlockattr_t;
typedef struct _pthread_spinlock pthread_spinlock_t;

struct _pthread_mutex {
 __haiku_std_uint32 flags;
 __haiku_std_int32 lock;
 __haiku_std_int32 unused;
 __haiku_std_int32 owner;
 __haiku_std_int32 owner_count;
};

struct _pthread_barrier {
 __haiku_std_uint32 flags;
 __haiku_std_int32 lock;
 __haiku_std_int32 mutex;
 __haiku_std_int32 waiter_count;
 __haiku_std_int32 waiter_max;
};

struct _pthread_cond {
 __haiku_std_uint32 flags;
 __haiku_std_int32 unused;
 pthread_mutex_t* mutex;
 __haiku_std_int32 waiter_count;
 __haiku_std_int32 lock;
};

struct _pthread_once {
 __haiku_std_int32 state;
};

struct _pthread_rwlock {
 __haiku_std_uint32 flags;
 __haiku_std_int32 owner;
 union {
  struct {
   __haiku_std_int32 mutex;
   __haiku_std_int32 unused;
   __haiku_std_int32 reader_count;
   __haiku_std_int32 writer_count;
   void* waiters[2];
  } local;
  struct {
   __haiku_std_int32 sem;
  } shared;
 } u;
};

struct _pthread_spinlock {
 __haiku_std_int32 lock;
};


typedef long int ptrdiff_t;
typedef long unsigned int size_t;
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;





typedef long signed int ssize_t;
typedef void* locale_t;


struct sigevent;


typedef __haiku_int32 clock_t;
typedef __haiku_int32 suseconds_t;
typedef __haiku_uint32 useconds_t;




typedef __haiku_int64 time_t;
struct timespec {
 time_t tv_sec;
 long tv_nsec;
};

struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 int tm_gmtoff;
 char *tm_zone;
};



extern char *tzname[2];
extern int daylight;
extern long timezone;



extern "C" {


extern clock_t clock(void);
extern double difftime(time_t time1, time_t time2);
extern time_t mktime(struct tm *tm);
extern time_t time(time_t *timer);
extern char *asctime(const struct tm *tm);
extern char *asctime_r(const struct tm *timep, char *buffer);
extern char *ctime(const time_t *timer);
extern char *ctime_r(const time_t *timer, char *buffer);
extern struct tm *gmtime(const time_t *timer);
extern struct tm *gmtime_r(const time_t *timer, struct tm *tm);
extern struct tm *localtime(const time_t *timer);
extern struct tm *localtime_r(const time_t *timer, struct tm *tm);
extern int nanosleep(const struct timespec *, struct timespec *);
extern size_t strftime(char *buffer, size_t maxSize, const char *format,
      const struct tm *tm);
extern size_t strftime_l(char *buffer, size_t maxSize, const char *format,
      const struct tm *tm, locale_t locale);
extern char *strptime(const char *buf, const char *format, struct tm *tm);


int clock_getres(clockid_t clockID, struct timespec* resolution);
int clock_gettime(clockid_t clockID, struct timespec* _time);
int clock_settime(clockid_t clockID, const struct timespec* _time);
int clock_nanosleep(clockid_t clockID, int flags,
   const struct timespec* _time, struct timespec* remainingTime);
int clock_getcpuclockid(pid_t pid, clockid_t* _clockID);


int timer_create(clockid_t clockID, struct sigevent* event,
   timer_t* timerID);
int timer_delete(timer_t timerID);
int timer_gettime(timer_t timerID, struct itimerspec* value);
int timer_settime(timer_t timerID, int flags,
   const struct itimerspec* value, struct itimerspec* oldValue);
int timer_getoverrun(timer_t timerID);


int timespec_get(struct timespec *ts, int base);


extern void tzset(void);


extern int stime(const time_t *t);


}



typedef __haiku_int8 int8;
typedef __haiku_uint8 uint8;
typedef __haiku_int16 int16;
typedef __haiku_uint16 uint16;
typedef __haiku_int32 int32;
typedef __haiku_uint32 uint32;
typedef __haiku_int64 int64;
typedef __haiku_uint64 uint64;


typedef volatile int8 vint8;
typedef volatile uint8 vuint8;
typedef volatile int16 vint16;
typedef volatile uint16 vuint16;
typedef volatile int32 vint32;
typedef volatile uint32 vuint32;
typedef volatile int64 vint64;
typedef volatile uint64 vuint64;

typedef volatile long vlong;
typedef volatile int vint;
typedef volatile short vshort;
typedef volatile char vchar;

typedef volatile unsigned long vulong;
typedef volatile unsigned int vuint;
typedef volatile unsigned short vushort;
typedef volatile unsigned char vuchar;

typedef unsigned char uchar;


typedef int32 status_t;
typedef int64 bigtime_t;
typedef int64 nanotime_t;
typedef uint32 type_code;
typedef uint32 perform_code;

typedef __haiku_phys_addr_t phys_addr_t;
typedef phys_addr_t phys_size_t;

typedef __haiku_generic_addr_t generic_addr_t;
typedef generic_addr_t generic_size_t;
extern const char *B_EMPTY_STRING;
extern "C" {



extern void* get_stack_frame(void);


}
static __inline__ void
atomic_set(int32* value, int32 newValue)
{
 __atomic_store_n(value, newValue, 3);
}


static __inline__ int32
atomic_get_and_set(int32* value, int32 newValue)
{
 return __atomic_exchange_n(value, newValue, 5);
}


static __inline__ int32
atomic_test_and_set(int32* value, int32 newValue, int32 testAgainst)
{
 __atomic_compare_exchange_n(value, &testAgainst, newValue, 1,
  5, 5);
 return testAgainst;
}


static __inline__ int32
atomic_add(int32* value, int32 addValue)
{
 return __atomic_fetch_add(value, addValue, 5);
}


static __inline__ int32
atomic_and(int32* value, int32 andValue)
{
 return __atomic_fetch_and(value, andValue, 5);
}


static __inline__ int32
atomic_or(int32* value, int32 orValue)
{
 return __atomic_fetch_or(value, orValue, 5);
}


static __inline__ int32
atomic_get(int32* value)
{
 return __atomic_load_n(value, 2);
}


static __inline__ void
atomic_set64(int64* value, int64 newValue)
{
 __atomic_store_n(value, newValue, 3);
}


static __inline__ int64
atomic_get_and_set64(int64* value, int64 newValue)
{
 return __atomic_exchange_n(value, newValue, 5);
}


static __inline__ int64
atomic_test_and_set64(int64* value, int64 newValue, int64 testAgainst)
{
 __atomic_compare_exchange_n(value, &testAgainst, newValue, 1,
  5, 5);
 return testAgainst;
}


static __inline__ int64
atomic_add64(int64* value, int64 addValue)
{
 return __atomic_fetch_add(value, addValue, 5);
}


static __inline__ int64
atomic_and64(int64* value, int64 andValue)
{
 return __atomic_fetch_and(value, andValue, 5);
}


static __inline__ int64
atomic_or64(int64* value, int64 orValue)
{
 return __atomic_fetch_or(value, orValue, 5);
}


static __inline__ int64
atomic_get64(int64* value)
{
 return __atomic_load_n(value, 2);
}



typedef struct pattern {
 uint8 data[8];
} pattern;



inline bool
operator==(const pattern& a, const pattern& b)
{
 uint64* pa = (uint64*)a.data;
 uint64* pb = (uint64*)b.data;
 return (*pa == *pb);
}


inline bool
operator!=(const pattern& a, const pattern& b)
{
 return !(a == b);
}



extern const pattern B_SOLID_HIGH;
extern const pattern B_MIXED_COLORS;
extern const pattern B_SOLID_LOW;



typedef struct rgb_color {
 uint8 red;
 uint8 green;
 uint8 blue;
 uint8 alpha;



 inline rgb_color&
 set_to(uint8 r, uint8 g, uint8 b, uint8 a = 255)
 {
  red = r;
  green = g;
  blue = b;
  alpha = a;
  return *this;
 }

 int32 Brightness() const;

 inline bool
 operator==(const rgb_color& other) const
 {
  return *(const uint32 *)this == *(const uint32 *)&other;
 }

 inline bool
 operator!=(const rgb_color& other) const
 {
  return *(const uint32 *)this != *(const uint32 *)&other;
 }

 inline rgb_color&
 operator=(const rgb_color& other)
 {
  return set_to(other.red, other.green, other.blue, other.alpha);
 }

} rgb_color;



inline rgb_color
make_color(uint8 red, uint8 green, uint8 blue, uint8 alpha = 255)
{
 rgb_color color = {red, green, blue, alpha};
 return color;
}



rgb_color mix_color(rgb_color color1, rgb_color color2, uint8 amount);
rgb_color blend_color(rgb_color color1, rgb_color color2, uint8 amount);
rgb_color disable_color(rgb_color color, rgb_color background);


extern const rgb_color B_TRANSPARENT_COLOR;
extern const uint8 B_TRANSPARENT_MAGIC_CMAP8;
extern const uint16 B_TRANSPARENT_MAGIC_RGBA15;
extern const uint16 B_TRANSPARENT_MAGIC_RGBA15_BIG;
extern const uint32 B_TRANSPARENT_MAGIC_RGBA32;
extern const uint32 B_TRANSPARENT_MAGIC_RGBA32_BIG;
extern const uint8 B_TRANSPARENT_8_BIT;
extern const rgb_color B_TRANSPARENT_32_BIT;



typedef struct color_map {
 int32 id;
 rgb_color color_list[256];
 uint8 inversion_map[256];
 uint8 index_map[32768];
} color_map;



typedef struct overlay_rect_limits {
 uint16 horizontal_alignment;
 uint16 vertical_alignment;
 uint16 width_alignment;
 uint16 height_alignment;
 uint16 min_width;
 uint16 max_width;
 uint16 min_height;
 uint16 max_height;
 uint32 reserved[8];
} overlay_rect_limits;


typedef struct overlay_restrictions {
 overlay_rect_limits source;
 overlay_rect_limits destination;
 float min_width_scale;
 float max_width_scale;
 float min_height_scale;
 float max_height_scale;
 uint32 reserved[8];
} overlay_restrictions;



struct screen_id { int32 id; };
extern const struct screen_id B_MAIN_SCREEN_ID;



typedef enum {
 B_NO_COLOR_SPACE = 0x0000,


 B_RGBA64 = 0x2012,
 B_RGB48 = 0x0011,
 B_RGB32 = 0x0008,
 B_RGBA32 = 0x2008,
 B_RGB24 = 0x0003,
 B_RGB16 = 0x0005,
 B_RGB15 = 0x0010,
 B_RGBA15 = 0x2010,
 B_CMAP8 = 0x0004,
 B_GRAY8 = 0x0002,
 B_GRAY1 = 0x0001,


 B_RGBA64_BIG = 0x3012,
 B_RGB48_BIG = 0x1011,
 B_RGB32_BIG = 0x1008,
 B_RGBA32_BIG = 0x3008,
 B_RGB24_BIG = 0x1003,
 B_RGB16_BIG = 0x1005,
 B_RGB15_BIG = 0x1010,
 B_RGBA15_BIG = 0x3010,


 B_RGBA64_LITTLE = B_RGBA64,
 B_RGB48_LITTLE = B_RGB48,
 B_RGB32_LITTLE = B_RGB32,
 B_RGBA32_LITTLE = B_RGBA32,
 B_RGB24_LITTLE = B_RGB24,
 B_RGB16_LITTLE = B_RGB16,
 B_RGB15_LITTLE = B_RGB15,
 B_RGBA15_LITTLE = B_RGBA15,
 B_YCbCr422 = 0x4000,

 B_YCbCr411 = 0x4001,


 B_YCbCr444 = 0x4003,
 B_YCbCr420 = 0x4004,
 B_YUV422 = 0x4020,

 B_YUV411 = 0x4021,

 B_YUV444 = 0x4023,
 B_YUV420 = 0x4024,


 B_YUV9 = 0x402C,
 B_YUV12 = 0x402D,

 B_UVL24 = 0x4030,
 B_UVL32 = 0x4031,
 B_UVLA32 = 0x6031,


 B_LAB24 = 0x4032,
 B_LAB32 = 0x4033,
 B_LABA32 = 0x6033,


 B_HSI24 = 0x4040,
 B_HSI32 = 0x4041,
 B_HSIA32 = 0x6041,

 B_HSV24 = 0x4042,
 B_HSV32 = 0x4043,
 B_HSVA32 = 0x6043,

 B_HLS24 = 0x4044,
 B_HLS32 = 0x4045,
 B_HLSA32 = 0x6045,

 B_CMY24 = 0xC001,
 B_CMY32 = 0xC002,
 B_CMYA32 = 0xE002,
 B_CMYK32 = 0xC003,


 B_MONOCHROME_1_BIT = B_GRAY1,
 B_GRAYSCALE_8_BIT = B_GRAY8,
 B_COLOR_8_BIT = B_CMAP8,
 B_RGB_32_BIT = B_RGB32,
 B_RGB_16_BIT = B_RGB15,
 B_BIG_RGB_32_BIT = B_RGB32_BIG,
 B_BIG_RGB_16_BIT = B_RGB15_BIG
} color_space;



enum {
 B_VIEWS_SUPPORT_DRAW_BITMAP = 0x1,
 B_BITMAPS_SUPPORT_ATTACHED_VIEWS = 0x2,
 B_BITMAPS_SUPPORT_OVERLAY = 0x4
};


bool bitmaps_support_space(color_space space, uint32* _supportFlags);


status_t get_pixel_size_for(color_space space, size_t* _pixelChunk,
 size_t* _rowAlignment, size_t* _pixelsPerChunk);


enum buffer_orientation {
 B_BUFFER_TOP_TO_BOTTOM,
 B_BUFFER_BOTTOM_TO_TOP
};


enum buffer_layout {
 B_BUFFER_NONINTERLEAVED = 1
};



enum drawing_mode {
 B_OP_COPY,
 B_OP_OVER,
 B_OP_ERASE,
 B_OP_INVERT,
 B_OP_ADD,
 B_OP_SUBTRACT,
 B_OP_BLEND,
 B_OP_MIN,
 B_OP_MAX,
 B_OP_SELECT,
 B_OP_ALPHA
};


enum source_alpha {
 B_PIXEL_ALPHA = 0,
 B_CONSTANT_ALPHA
};


enum alpha_function {
 B_ALPHA_OVERLAY = 0,
 B_ALPHA_COMPOSITE,
 B_ALPHA_COMPOSITE_SOURCE_OVER = B_ALPHA_COMPOSITE,
 B_ALPHA_COMPOSITE_SOURCE_IN,
 B_ALPHA_COMPOSITE_SOURCE_OUT,
 B_ALPHA_COMPOSITE_SOURCE_ATOP,
 B_ALPHA_COMPOSITE_DESTINATION_OVER,
 B_ALPHA_COMPOSITE_DESTINATION_IN,
 B_ALPHA_COMPOSITE_DESTINATION_OUT,
 B_ALPHA_COMPOSITE_DESTINATION_ATOP,
 B_ALPHA_COMPOSITE_XOR,
 B_ALPHA_COMPOSITE_CLEAR,
 B_ALPHA_COMPOSITE_DIFFERENCE,
 B_ALPHA_COMPOSITE_LIGHTEN,
 B_ALPHA_COMPOSITE_DARKEN
};



enum {
 B_8_BIT_640x480 = 0x00000001,
 B_8_BIT_800x600 = 0x00000002,
 B_8_BIT_1024x768 = 0x00000004,
 B_8_BIT_1280x1024 = 0x00000008,
 B_8_BIT_1600x1200 = 0x00000010,
 B_16_BIT_640x480 = 0x00000020,
 B_16_BIT_800x600 = 0x00000040,
 B_16_BIT_1024x768 = 0x00000080,
 B_16_BIT_1280x1024 = 0x00000100,
 B_16_BIT_1600x1200 = 0x00000200,
 B_32_BIT_640x480 = 0x00000400,
 B_32_BIT_800x600 = 0x00000800,
 B_32_BIT_1024x768 = 0x00001000,
 B_32_BIT_1280x1024 = 0x00002000,
 B_32_BIT_1600x1200 = 0x00004000,
 B_8_BIT_1152x900 = 0x00008000,
 B_16_BIT_1152x900 = 0x00010000,
 B_32_BIT_1152x900 = 0x00020000,
 B_15_BIT_640x480 = 0x00040000,
 B_15_BIT_800x600 = 0x00080000,
 B_15_BIT_1024x768 = 0x00100000,
 B_15_BIT_1280x1024 = 0x00200000,
 B_15_BIT_1600x1200 = 0x00400000,
 B_15_BIT_1152x900 = 0x00800000,
 B_8_BIT_640x400 = 0x80000000
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;



struct stat {
 dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 off_t st_size;
 dev_t st_rdev;
 blksize_t st_blksize;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 struct timespec st_crtim;
 __haiku_uint32 st_type;
 blkcnt_t st_blocks;
};
extern "C" {


extern int chmod(const char *path, mode_t mode);
extern int fchmod(int fd, mode_t mode);
extern int fchmodat(int fd, const char *path, mode_t mode, int flag);
extern int stat(const char *path, struct stat *st);
extern int fstat(int fd, struct stat *st);
extern int lstat(const char *path, struct stat *st);
extern int fstatat(int fd, const char *path, struct stat *st, int flag);
extern int mkdir(const char *path, mode_t mode);
extern int mkdirat(int fd, const char *path, mode_t mode);
extern int mkfifo(const char *path, mode_t mode);
extern int mkfifoat(int fd, const char *path, mode_t mode);
extern int mknod(const char *name, mode_t mode, dev_t dev);
extern int mknodat(int fd, const char *name, mode_t mode, dev_t dev);
extern mode_t umask(mode_t cmask);

extern int utimensat(int fd, const char *path,
     const struct timespec times[2], int flag);
extern int futimens(int fd, const struct timespec times[2]);


}
extern "C" {



extern int access(const char *path, int accessMode);
extern int faccessat(int fd, const char *path, int accessMode, int flag);

extern int chdir(const char *path);
extern int fchdir(int fd);
extern char *getcwd(char *buffer, size_t size);

extern int pipe(int fildes[2]);
extern int dup(int fd);
extern int dup2(int fd1, int fd2);
extern int close(int fd);
extern int link(const char *toPath, const char *path);
extern int linkat(int toFD, const char *toPath, int pathFD,
     const char *path, int flag);
extern int unlink(const char *name);
extern int unlinkat(int fd, const char *path, int flag);
extern int rmdir(const char *path);

extern ssize_t readlink(const char *path, char *buffer, size_t bufferSize);
extern ssize_t readlinkat(int fd, const char *path, char *buffer,
     size_t bufferSize);
extern int symlink(const char *toPath, const char *symlinkPath);
extern int symlinkat(const char *toPath, int fd, const char *symlinkPath);

extern int ftruncate(int fd, off_t newSize);
extern int truncate(const char *path, off_t newSize);
struct ioctl_args {
    void* argument;
    size_t size;
};
int __ioctl(int fd, ulong cmd, struct ioctl_args args);






inline int
ioctl(int fd, unsigned long op, void* argument = __null, size_t size = 0)
{
 return __ioctl(fd, op, (struct ioctl_args){ argument, size });
}


extern ssize_t read(int fd, void *buffer, size_t count);
extern ssize_t read_pos(int fd, off_t pos, void *buffer, size_t count);
extern ssize_t pread(int fd, void *buffer, size_t count, off_t pos);
extern ssize_t write(int fd, const void *buffer, size_t count);
extern ssize_t write_pos(int fd, off_t pos, const void *buffer,size_t count);
extern ssize_t pwrite(int fd, const void *buffer, size_t count, off_t pos);
extern off_t lseek(int fd, off_t offset, int whence);

extern void sync(void);
extern int fsync(int fd);

extern int chown(const char *path, uid_t owner, gid_t group);
extern int fchown(int fd, uid_t owner, gid_t group);
extern int lchown(const char *path, uid_t owner, gid_t group);
extern int fchownat(int fd, const char *path, uid_t owner, gid_t group,
     int flag);

extern int getpagesize(void);
extern int getdtablesize(void);
extern long sysconf(int name);
extern long fpathconf(int fd, int name);
extern long pathconf(const char *path, int name);
extern size_t confstr(int name, char *buf, size_t len);
extern int lockf(int fd, int function, off_t size);


extern pid_t fork(void);
extern pid_t vfork(void);
extern int execve(const char *path, char * const argv[],
     char *const environment[]);
extern int execl(const char *path, const char *arg, ...);
extern int execv(const char *path, char *const argv[]);
extern int execlp(const char *file, const char *arg, ...);
extern int execle(const char *path, const char *arg , ... );
extern int execvp(const char *file, char *const argv[]);
extern int execvpe(const char *file, char *const argv[],
     char *const environment[]);

extern void _exit(int status) __attribute__ ((noreturn));

extern pid_t tcgetpgrp(int fd);
extern int tcsetpgrp(int fd, pid_t pgrpid);

extern int brk(void *addr);
extern void *sbrk(intptr_t increment);

extern unsigned int alarm(unsigned int seconds);
extern useconds_t ualarm(useconds_t microSeconds, useconds_t interval);
extern unsigned int sleep(unsigned int seconds);
extern int usleep(unsigned int microSeconds);
extern int pause(void);


extern pid_t getpid(void);
extern pid_t getpgrp(void);
extern pid_t getppid(void);
extern pid_t getsid(pid_t pid);
extern pid_t getpgid(pid_t pid);

extern pid_t setsid(void);
extern int setpgid(pid_t pid, pid_t pgid);
extern pid_t setpgrp(void);

extern int chroot(const char *path);

extern int nice(int incr);


extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern uid_t getuid(void);

extern int setgid(gid_t gid);
extern int setuid(uid_t uid);
extern int setegid(gid_t gid);
extern int seteuid(uid_t uid);
extern int setregid(gid_t rgid, gid_t egid);
extern int setreuid(uid_t ruid, uid_t euid);

extern int getgrouplist(const char* user, gid_t baseGroup,
     gid_t* groupList, int* groupCount);
extern int getgroups(int groupCount, gid_t groupList[]);
extern int initgroups(const char* user, gid_t baseGroup);
extern int setgroups(int groupCount, const gid_t* groupList);

extern char *getlogin(void);
extern int getlogin_r(char *name, size_t nameSize);


extern int sethostname(const char *hostName, size_t nameSize);
extern int gethostname(char *hostName, size_t nameSize);


extern int isatty(int fd);
extern char *ttyname(int fd);
extern int ttyname_r(int fd, char *buffer, size_t bufferSize);


extern char *crypt(const char *key, const char *salt);
extern void encrypt(char block[64], int edflag);
extern int getopt(int argc, char *const *argv, const char *shortOpts);
extern void swab(const void *src, void *dest, ssize_t nbytes);


extern char *optarg;
extern int optind, opterr, optopt;


}
struct flock {
 short l_type;
 short l_whence;
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
};



extern "C" {


extern int creat(const char *path, mode_t mode);
extern int open(const char *path, int openMode, ...);


extern int openat(int fd, const char *path, int openMode, ...);

extern int fcntl(int fd, int op, ...);

extern int posix_fadvise(int fd, off_t offset, off_t len, int advice);
extern int posix_fallocate(int fd, off_t offset, off_t len);


}
enum node_flavor {
 B_FILE_NODE = 0x01,
 B_SYMLINK_NODE = 0x02,
 B_DIRECTORY_NODE = 0x04,
 B_ANY_NODE = 0x07
};



extern "C" {
enum {
 B_TIMEOUT = 0x8,
 B_RELATIVE_TIMEOUT = 0x8,

 B_ABSOLUTE_TIMEOUT = 0x10,



 B_TIMEOUT_REAL_TIME_BASE = 0x40,
 B_ABSOLUTE_REAL_TIME_TIMEOUT = B_ABSOLUTE_TIMEOUT
          | B_TIMEOUT_REAL_TIME_BASE
};




typedef int32 area_id;
typedef int32 port_id;
typedef int32 sem_id;
typedef int32 team_id;
typedef int32 thread_id;




typedef struct area_info {
 area_id area;
 char name[32];
 size_t size;
 uint32 lock;
 uint32 protection;
 team_id team;
 uint32 ram_size;
 uint32 copy_count;
 uint32 in_count;
 uint32 out_count;
 void *address;
} area_info;
extern area_id create_area(const char *name, void **startAddress,
      uint32 addressSpec, size_t size, uint32 lock,
      uint32 protection);
extern area_id clone_area(const char *name, void **destAddress,
      uint32 addressSpec, uint32 protection, area_id source);
extern area_id find_area(const char *name);
extern area_id area_for(void *address);
extern status_t delete_area(area_id id);
extern status_t resize_area(area_id id, size_t newSize);
extern status_t set_area_protection(area_id id, uint32 newProtection);


extern status_t _get_area_info(area_id id, area_info *areaInfo, size_t size);
extern status_t _get_next_area_info(team_id team, ssize_t *cookie,
      area_info *areaInfo, size_t size);
typedef struct port_info {
 port_id port;
 team_id team;
 char name[32];
 int32 capacity;
 int32 queue_count;
 int32 total_count;
} port_info;

extern port_id create_port(int32 capacity, const char *name);
extern port_id find_port(const char *name);
extern ssize_t read_port(port_id port, int32 *code, void *buffer,
      size_t bufferSize);
extern ssize_t read_port_etc(port_id port, int32 *code, void *buffer,
      size_t bufferSize, uint32 flags, bigtime_t timeout);
extern status_t write_port(port_id port, int32 code, const void *buffer,
      size_t bufferSize);
extern status_t write_port_etc(port_id port, int32 code, const void *buffer,
      size_t bufferSize, uint32 flags, bigtime_t timeout);
extern status_t close_port(port_id port);
extern status_t delete_port(port_id port);

extern ssize_t port_buffer_size(port_id port);
extern ssize_t port_buffer_size_etc(port_id port, uint32 flags,
      bigtime_t timeout);
extern ssize_t port_count(port_id port);
extern status_t set_port_owner(port_id port, team_id team);


extern status_t _get_port_info(port_id port, port_info *portInfo,
      size_t portInfoSize);
extern status_t _get_next_port_info(team_id team, int32 *cookie,
      port_info *portInfo, size_t portInfoSize);
typedef struct port_message_info {
 size_t size;
 uid_t sender;
 gid_t sender_group;
 team_id sender_team;
} port_message_info;


extern status_t _get_port_message_info_etc(port_id port,
      port_message_info *info, size_t infoSize, uint32 flags,
      bigtime_t timeout);







typedef struct sem_info {
 sem_id sem;
 team_id team;
 char name[32];
 int32 count;
 thread_id latest_holder;
} sem_info;


enum {
 B_CAN_INTERRUPT = 0x01,

 B_CHECK_PERMISSION = 0x04,

 B_KILL_CAN_INTERRUPT = 0x20,





 B_DO_NOT_RESCHEDULE = 0x02,
 B_RELEASE_ALL = 0x08,

 B_RELEASE_IF_WAITING_ONLY = 0x10

};

extern sem_id create_sem(int32 count, const char *name);
extern status_t delete_sem(sem_id id);
extern status_t acquire_sem(sem_id id);
extern status_t acquire_sem_etc(sem_id id, int32 count, uint32 flags,
      bigtime_t timeout);
extern status_t release_sem(sem_id id);
extern status_t release_sem_etc(sem_id id, int32 count, uint32 flags);


extern status_t switch_sem(sem_id semToBeReleased, sem_id id);
extern status_t switch_sem_etc(sem_id semToBeReleased, sem_id id,
      int32 count, uint32 flags, bigtime_t timeout);
extern status_t get_sem_count(sem_id id, int32 *threadCount);
extern status_t set_sem_owner(sem_id id, team_id team);


extern status_t _get_sem_info(sem_id id, struct sem_info *info,
      size_t infoSize);
extern status_t _get_next_sem_info(team_id team, int32 *cookie,
      struct sem_info *info, size_t infoSize);
typedef struct {
 team_id team;
 int32 thread_count;
 int32 image_count;
 int32 area_count;
 thread_id debugger_nub_thread;
 port_id debugger_nub_port;
 int32 argc;
 char args[64];
 uid_t uid;
 gid_t gid;


 uid_t real_uid;
 gid_t real_gid;
 pid_t group_id;
 pid_t session_id;
 team_id parent;
 char name[32];
 bigtime_t start_time;
} team_info;




extern status_t kill_team(team_id team);



extern status_t _get_team_info(team_id id, team_info *info, size_t size);
extern status_t _get_next_team_info(int32 *cookie, team_info *info,
      size_t size);
typedef struct {
 bigtime_t user_time;
 bigtime_t kernel_time;
} team_usage_info;

enum {

 B_TEAM_USAGE_SELF = 0,
 B_TEAM_USAGE_CHILDREN = -1
};


extern status_t _get_team_usage_info(team_id team, int32 who,
      team_usage_info *info, size_t size);







typedef enum {
 B_THREAD_RUNNING = 1,
 B_THREAD_READY,
 B_THREAD_RECEIVING,
 B_THREAD_ASLEEP,
 B_THREAD_SUSPENDED,
 B_THREAD_WAITING
} thread_state;

typedef struct {
 thread_id thread;
 team_id team;
 char name[32];
 thread_state state;
 int32 priority;
 sem_id sem;
 bigtime_t user_time;
 bigtime_t kernel_time;
 void *stack_base;
 void *stack_end;
} thread_info;
typedef status_t (*thread_func)(void *);



extern thread_id spawn_thread(thread_func, const char *name, int32 priority,
      void *data);
extern status_t kill_thread(thread_id thread);
extern status_t resume_thread(thread_id thread);
extern status_t suspend_thread(thread_id thread);

extern status_t rename_thread(thread_id thread, const char *newName);
extern status_t set_thread_priority(thread_id thread, int32 newPriority);
extern void exit_thread(status_t status);
extern status_t wait_for_thread(thread_id thread, status_t *returnValue);
extern status_t wait_for_thread_etc(thread_id id, uint32 flags, bigtime_t timeout,
      status_t *_returnCode);
extern status_t on_exit_thread(void (*callback)(void *), void *data);

extern thread_id find_thread(const char *name);

extern status_t send_data(thread_id thread, int32 code, const void *buffer,
      size_t bufferSize);
extern int32 receive_data(thread_id *sender, void *buffer,
      size_t bufferSize);
extern bool has_data(thread_id thread);

extern status_t snooze(bigtime_t amount);
extern status_t snooze_etc(bigtime_t amount, int timeBase, uint32 flags);
extern status_t snooze_until(bigtime_t time, int timeBase);


extern status_t _get_thread_info(thread_id id, thread_info *info, size_t size);
extern status_t _get_next_thread_info(team_id team, int32 *cookie,
      thread_info *info, size_t size);
extern thread_id get_pthread_thread_id(pthread_t thread);
extern unsigned long real_time_clock(void);
extern void set_real_time_clock(unsigned long secsSinceJan1st1970);
extern bigtime_t real_time_clock_usecs(void);
extern bigtime_t system_time(void);

extern nanotime_t system_time_nsecs(void);




enum {
 B_ONE_SHOT_ABSOLUTE_ALARM = 1,
 B_ONE_SHOT_RELATIVE_ALARM,
 B_PERIODIC_ALARM
};

extern bigtime_t set_alarm(bigtime_t when, uint32 flags);




extern void debugger(const char *message);
extern int disable_debugger(int state);


extern void debug_printf(const char *format, ...)
      __attribute__ ((format (__printf__, 1, 2)));
extern void debug_vprintf(const char *format, va_list args);
extern void ktrace_printf(const char *format, ...)
      __attribute__ ((format (__printf__, 1, 2)));
extern void ktrace_vprintf(const char *format, va_list args);




typedef struct {
 bigtime_t active_time;
 bool enabled;
 uint64 current_frequency;
} cpu_info;

typedef struct {
 bigtime_t boot_time;

 uint32 cpu_count;

 uint64 max_pages;
 uint64 used_pages;
 uint64 cached_pages;
 uint64 block_cache_pages;
 uint64 ignored_pages;

 uint64 needed_memory;
 uint64 free_memory;

 uint64 max_swap_pages;
 uint64 free_swap_pages;

 uint32 page_faults;

 uint32 max_sems;
 uint32 used_sems;

 uint32 max_ports;
 uint32 used_ports;

 uint32 max_threads;
 uint32 used_threads;

 uint32 max_teams;
 uint32 used_teams;

 char kernel_name[(256)];
 char kernel_build_date[32];
 char kernel_build_time[32];

 int64 kernel_version;
 uint32 abi;
} system_info;

enum topology_level_type {
 B_TOPOLOGY_UNKNOWN,
 B_TOPOLOGY_ROOT,
 B_TOPOLOGY_SMT,
 B_TOPOLOGY_CORE,
 B_TOPOLOGY_PACKAGE
};

enum cpu_platform {
 B_CPU_UNKNOWN,
 B_CPU_x86,
 B_CPU_x86_64,
 B_CPU_PPC,
 B_CPU_PPC_64,
 B_CPU_M68K,
 B_CPU_ARM,
 B_CPU_ARM_64,
 B_CPU_ALPHA,
 B_CPU_MIPS,
 B_CPU_SH,
 B_CPU_SPARC,
 B_CPU_RISC_V
};

enum cpu_vendor {
 B_CPU_VENDOR_UNKNOWN,
 B_CPU_VENDOR_AMD,
 B_CPU_VENDOR_CYRIX,
 B_CPU_VENDOR_IDT,
 B_CPU_VENDOR_INTEL,
 B_CPU_VENDOR_NATIONAL_SEMICONDUCTOR,
 B_CPU_VENDOR_RISE,
 B_CPU_VENDOR_TRANSMETA,
 B_CPU_VENDOR_VIA,
 B_CPU_VENDOR_IBM,
 B_CPU_VENDOR_MOTOROLA,
 B_CPU_VENDOR_NEC,
 B_CPU_VENDOR_HYGON,
 B_CPU_VENDOR_SUN,
 B_CPU_VENDOR_FUJITSU
};

typedef struct {
 enum cpu_platform platform;
} cpu_topology_root_info;

typedef struct {
 enum cpu_vendor vendor;
 uint32 cache_line_size;
} cpu_topology_package_info;

typedef struct {
 uint32 model;
 uint64 default_frequency;
} cpu_topology_core_info;

typedef struct {
 uint32 id;
 enum topology_level_type type;
 uint32 level;

 union {
  cpu_topology_root_info root;
  cpu_topology_package_info package;
  cpu_topology_core_info core;
 } data;
} cpu_topology_node_info;


extern status_t get_system_info(system_info* info);
extern status_t _get_cpu_info_etc(uint32 firstCPU, uint32 cpuCount,
      cpu_info* info, size_t size);



extern status_t get_cpu_topology_info(cpu_topology_node_info* topologyInfos,
      uint32* topologyInfoCount);


typedef union {
 struct {
  uint32 max_eax;
  char vendor_id[12];
 } eax_0;

 struct {
  uint32 stepping : 4;
  uint32 model : 4;
  uint32 family : 4;
  uint32 type : 2;
  uint32 reserved_0 : 2;
  uint32 extended_model : 4;
  uint32 extended_family : 8;
  uint32 reserved_1 : 4;

  uint32 brand_index : 8;
  uint32 clflush : 8;
  uint32 logical_cpus : 8;
  uint32 apic_id : 8;

  uint32 features;
  uint32 extended_features;
 } eax_1;

 struct {
  uint8 call_num;
  uint8 cache_descriptors[15];
 } eax_2;

 struct {
  uint32 reserved[2];
  uint32 serial_number_high;
  uint32 serial_number_low;
 } eax_3;

 char as_chars[16];

 struct {
  uint32 eax;
  uint32 ebx;
  uint32 edx;
  uint32 ecx;
 } regs;
} cpuid_info;

extern status_t get_cpuid(cpuid_info *info, uint32 eaxRegister,
      uint32 cpuNum);



extern int32 is_computer_on(void);
extern double is_computer_on_fire(void);



int send_signal(thread_id threadID, unsigned int signal);
void set_signal_stack(void* base, size_t size);




enum {
 B_OBJECT_TYPE_FD = 0,
 B_OBJECT_TYPE_SEMAPHORE = 1,
 B_OBJECT_TYPE_PORT = 2,
 B_OBJECT_TYPE_THREAD = 3
};

enum {
 B_EVENT_READ = 0x0001,
 B_EVENT_WRITE = 0x0002,
 B_EVENT_ERROR = 0x0004,
 B_EVENT_PRIORITY_READ = 0x0008,
 B_EVENT_PRIORITY_WRITE = 0x0010,
 B_EVENT_HIGH_PRIORITY_READ = 0x0020,
 B_EVENT_HIGH_PRIORITY_WRITE = 0x0040,
 B_EVENT_DISCONNECTED = 0x0080,

 B_EVENT_ACQUIRE_SEMAPHORE = 0x0001,

 B_EVENT_INVALID = 0x1000,


};

typedef struct object_wait_info {
 int32 object;
 uint16 type;
 uint16 events;
} object_wait_info;
extern ssize_t wait_for_objects(object_wait_info* infos, int numInfos);
extern ssize_t wait_for_objects_etc(object_wait_info* infos, int numInfos,
      uint32 flags, bigtime_t timeout);



}
extern "C" {




extern void *memchr(const void *source, int value, size_t length);
extern int memcmp(const void *buffer1, const void *buffer2, size_t length);
extern void *memcpy(void *dest, const void *source, size_t length);
extern void *memccpy(void *dest, const void *source, int stopByte, size_t length);
extern void *memmove(void *dest, const void *source, size_t length);
extern void *memset(void *dest, int value, size_t length);






extern char *strcpy(char *dest, const char *source);
extern char *strncpy(char *dest, const char *source, size_t length);
extern char *strcat(char *dest, const char *source);
extern char *strncat(char *dest, const char *source, size_t length);

extern size_t strlen(const char *string);
extern int strcmp(const char *string1, const char *string2);
extern int strncmp(const char *string1, const char *string2, size_t length);

extern char *strchr(const char *string, int character);
extern char *strrchr(const char *string, int character);
extern char *strstr(const char *string, const char *searchString);





extern char *strpbrk(const char *string, const char *set);
extern char *strtok(char *string, const char *set);
extern char *strtok_r(char *string, const char *set, char **savePointer);
extern size_t strspn(const char *string, const char *set);
extern size_t strcspn(const char *string, const char *set);

extern int strcoll(const char *string1, const char *string2);
extern size_t strxfrm(char *string1, const char *string2, size_t length);

extern char *strerror(int errorCode);
extern int strerror_r(int errorCode, char *buffer, size_t bufferSize);

extern char *strcasestr(const char *string, const char *searchString);

extern char *strdup(const char *string);
extern char *strndup(const char* string, size_t size);
extern char *stpcpy(char *dest, const char *source);
extern char *stpncpy(char *dest, const char *source, size_t size);

extern size_t strlcat(char *dest, const char *source, size_t length);
extern size_t strlcpy(char *dest, const char *source, size_t length);

extern size_t strnlen(const char *string, size_t count);

extern char *strlwr(char *string);
extern char *strupr(char *string);



extern const char *strsignal(int signum);


extern int strcoll_l(const char *string1, const char *string2, locale_t locale);
extern char *strerror_l(int errorCode, locale_t locale);
extern size_t strxfrm_l(char *string1, const char *string2, size_t length, locale_t locale);


extern "C" {


static __inline__ int ffs(int i) { return __builtin_ffs(i); }

extern int strcasecmp(const char *string1, const char *string2);
extern int strncasecmp(const char *string1, const char *string2,
 size_t length);

extern int strcasecmp_l(const char *string1, const char *string2, locale_t locale);
extern int strncasecmp_l(const char *string1, const char *string2,
 size_t length, locale_t locale);






extern char *index(const char *s, int c);
extern char *rindex(char const *s, int c);


}



}




class BStringList;
class BStringRef;


class BString {
public:
       BString();
       BString(const char* string);
       BString(const BString& string);
       BString(const char* string, int32 maxLength);

       BString(BString&& string) noexcept;

       ~BString();


   const char* String() const;
   int32 Length() const;
   int32 CountChars() const;
   int32 CountBytes(int32 fromCharOffset,
        int32 charCount) const;
   bool IsEmpty() const;

   uint32 HashValue() const;
 static uint32 HashValue(const char* string);


   BString& operator=(const BString& string);
   BString& operator=(const char* string);
   BString& operator=(char c);

   BString& operator=(BString&& string) noexcept;


   BString& SetTo(const char* string);
   BString& SetTo(const char* string, int32 maxLength);

   BString& SetTo(const BString& string);
   BString& Adopt(BString& from);

   BString& SetTo(const BString& string, int32 maxLength);
   BString& Adopt(BString& from, int32 maxLength);

   BString& SetTo(char c, int32 count);

   BString& SetToChars(const char* string, int32 charCount);
   BString& SetToChars(const BString& string, int32 charCount);
   BString& AdoptChars(BString& from, int32 charCount);

   BString& SetToFormat(const char* format, ...)
        __attribute__((__format__(__printf__, 2, 3)));
   BString& SetToFormatVarArgs(const char* format,
        va_list args)
        __attribute__((__format__(__printf__, 2, 0)));

   int ScanWithFormat(const char* format, ...)
        __attribute__((__format__(__scanf__, 2, 3)));
   int ScanWithFormatVarArgs(const char* format,
        va_list args)
        __attribute__((__format__(__scanf__, 2, 0)));


   BString& CopyInto(BString& into, int32 fromOffset,
        int32 length) const;
   void CopyInto(char* into, int32 fromOffset,
        int32 length) const;

   BString& CopyCharsInto(BString& into, int32 fromCharOffset,
        int32 charCount) const;
   bool CopyCharsInto(char* into, int32* intoLength,
        int32 fromCharOffset, int32 charCount) const;

   bool Split(const char* separator, bool noEmptyStrings,
        BStringList& _list) const;


   BString& operator+=(const BString& string);
   BString& operator+=(const char* string);
   BString& operator+=(char c);

   BString& Append(const BString& string);
   BString& Append(const char* string);

   BString& Append(const BString& string, int32 length);
   BString& Append(const char* string, int32 length);
   BString& Append(char c, int32 count);

   BString& AppendChars(const BString& string, int32 charCount);
   BString& AppendChars(const char* string, int32 charCount);


   BString& Prepend(const char* string);
   BString& Prepend(const BString& string);
   BString& Prepend(const char* string, int32 length);
   BString& Prepend(const BString& string, int32 length);
   BString& Prepend(char c, int32 count);

   BString& PrependChars(const char* string, int32 charCount);
   BString& PrependChars(const BString& string,
        int32 charCount);


   BString& Insert(const char* string, int32 position);
   BString& Insert(const char* string, int32 length,
        int32 position);
   BString& Insert(const char* string, int32 fromOffset,
        int32 length, int32 position);
   BString& Insert(const BString& string, int32 position);
   BString& Insert(const BString& string, int32 length,
        int32 position);
   BString& Insert(const BString& string, int32 fromOffset,
        int32 length, int32 position);
   BString& Insert(char c, int32 count, int32 position);

   BString& InsertChars(const char* string, int32 charPosition);
   BString& InsertChars(const char* string, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const char* string,
        int32 fromCharOffset, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const BString& string,
        int32 charPosition);
   BString& InsertChars(const BString& string, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const BString& string,
        int32 fromCharOffset, int32 charCount,
        int32 charPosition);


   BString& Truncate(int32 newLength, bool lazy = true);
   BString& TruncateChars(int32 newCharCount, bool lazy = true);

   BString& Remove(int32 from, int32 length);
   BString& RemoveChars(int32 fromCharOffset, int32 charCount);

   BString& RemoveFirst(const BString& string);
   BString& RemoveLast(const BString& string);
   BString& RemoveAll(const BString& string);

   BString& RemoveFirst(const char* string);
   BString& RemoveLast(const char* string);
   BString& RemoveAll(const char* string);

   BString& RemoveSet(const char* setOfBytesToRemove);
   BString& RemoveCharsSet(const char* setOfCharsToRemove);

   BString& MoveInto(BString& into, int32 from, int32 length);
   void MoveInto(char* into, int32 from, int32 length);

   BString& MoveCharsInto(BString& into, int32 fromCharOffset,
        int32 charCount);
   bool MoveCharsInto(char* into, int32* intoLength,
        int32 fromCharOffset, int32 charCount);


   bool operator<(const BString& string) const;
   bool operator<=(const BString& string) const;
   bool operator==(const BString& string) const;
   bool operator>=(const BString& string) const;
   bool operator>(const BString& string) const;
   bool operator!=(const BString& string) const;

   bool operator<(const char* string) const;
   bool operator<=(const char* string) const;
   bool operator==(const char* string) const;
   bool operator>=(const char* string) const;
   bool operator>(const char* string) const;
   bool operator!=(const char* string) const;

       operator const char*() const;


   int Compare(const BString& string) const;
   int Compare(const char* string) const;
   int Compare(const BString& string, int32 length) const;
   int Compare(const char* string, int32 length) const;

   int CompareAt(size_t offset, const BString& string,
        int32 length) const;

   int CompareChars(const BString& string,
        int32 charCount) const;
   int CompareChars(const char* string,
        int32 charCount) const;

   int ICompare(const BString& string) const;
   int ICompare(const char* string) const;
   int ICompare(const BString& string, int32 length) const;
   int ICompare(const char* string, int32 length) const;


   int32 FindFirst(const BString& string) const;
   int32 FindFirst(const char* string) const;
   int32 FindFirst(const BString& string,
        int32 fromOffset) const;
   int32 FindFirst(const char* string,
        int32 fromOffset) const;
   int32 FindFirst(char c) const;
   int32 FindFirst(char c, int32 fromOffset) const;

   int32 FindFirstChars(const BString& string,
        int32 fromCharOffset) const;
   int32 FindFirstChars(const char* string,
        int32 fromCharOffset) const;

   int32 FindLast(const BString& string) const;
   int32 FindLast(const char* string) const;
   int32 FindLast(const BString& string,
        int32 beforeOffset) const;
   int32 FindLast(const char* string,
        int32 beforeOffset) const;
   int32 FindLast(char c) const;
   int32 FindLast(char c, int32 beforeOffset) const;

   int32 FindLastChars(const BString& string,
        int32 beforeCharOffset) const;
   int32 FindLastChars(const char* string,
        int32 beforeCharOffset) const;

   int32 IFindFirst(const BString& string) const;
   int32 IFindFirst(const char* string) const;
   int32 IFindFirst(const BString& string,
        int32 fromOffset) const;
   int32 IFindFirst(const char* string,
        int32 fromOffset) const;

   int32 IFindLast(const BString& string) const;
   int32 IFindLast(const char* string) const;
   int32 IFindLast(const BString& string,
        int32 beforeOffset) const;
   int32 IFindLast(const char* string,
        int32 beforeOffset) const;

   bool StartsWith(const BString& string) const;
   bool StartsWith(const char* string) const;
   bool StartsWith(const char* string, int32 length) const;

   bool IStartsWith(const BString& string) const;
   bool IStartsWith(const char* string) const;
   bool IStartsWith(const char* string, int32 length) const;

   bool EndsWith(const BString& string) const;
   bool EndsWith(const char* string) const;
   bool EndsWith(const char* string, int32 length) const;

   bool IEndsWith(const BString& string) const;
   bool IEndsWith(const char* string) const;
   bool IEndsWith(const char* string, int32 length) const;


   BString& ReplaceFirst(char replaceThis, char withThis);
   BString& ReplaceLast(char replaceThis, char withThis);
   BString& ReplaceAll(char replaceThis, char withThis,
        int32 fromOffset = 0);
   BString& Replace(char replaceThis, char withThis,
        int32 maxReplaceCount, int32 fromOffset = 0);
   BString& ReplaceFirst(const char* replaceThis,
        const char* withThis);
   BString& ReplaceLast(const char* replaceThis,
        const char* withThis);
   BString& ReplaceAll(const char* replaceThis,
        const char* withThis, int32 fromOffset = 0);
   BString& Replace(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromOffset = 0);

   BString& ReplaceAllChars(const char* replaceThis,
        const char* withThis, int32 fromCharOffset);
   BString& ReplaceChars(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromCharOffset);

   BString& IReplaceFirst(char replaceThis, char withThis);
   BString& IReplaceLast(char replaceThis, char withThis);
   BString& IReplaceAll(char replaceThis, char withThis,
        int32 fromOffset = 0);
   BString& IReplace(char replaceThis, char withThis,
        int32 maxReplaceCount, int32 fromOffset = 0);
   BString& IReplaceFirst(const char* replaceThis,
        const char* withThis);
   BString& IReplaceLast(const char* replaceThis,
        const char* withThis);
   BString& IReplaceAll(const char* replaceThis,
        const char* withThis, int32 fromOffset = 0);
   BString& IReplace(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromOffset = 0);

   BString& ReplaceSet(const char* setOfBytes, char with);
   BString& ReplaceSet(const char* setOfBytes,
        const char* with);

   BString& ReplaceCharsSet(const char* setOfChars,
        const char* with);


   char operator[](int32 index) const;






   char ByteAt(int32 index) const;
   const char* CharAt(int32 charIndex, int32* bytes = __null) const;
   bool CharAt(int32 charIndex, char* buffer,
        int32* bytes) const;


   char* LockBuffer(int32 maxLength);
   BString& UnlockBuffer(int32 length = -1);
   BString& SetByteAt(int32 pos, char to);


   BString& ToLower();
   BString& ToUpper();

   BString& Capitalize();
   BString& CapitalizeEachWord();


   BString& CharacterEscape(const char* original,
        const char* setOfCharsToEscape,
        char escapeWith);
   BString& CharacterEscape(const char* setOfCharsToEscape,
        char escapeWith);
   BString& CharacterDeescape(const char* original,
        char escapeChar);
   BString& CharacterDeescape(char escapeChar);


   BString& Trim();


   BString& operator<<(const char* string);
   BString& operator<<(const BString& string);
   BString& operator<<(char c);
   BString& operator<<(bool value);
   BString& operator<<(int value);
   BString& operator<<(unsigned int value);
   BString& operator<<(unsigned long value);
   BString& operator<<(long value);
   BString& operator<<(unsigned long long value);
   BString& operator<<(long long value);

   BString& operator<<(float value);
   BString& operator<<(double value);

public:
   class Private;
   friend class Private;

private:
   class PosVect;
   friend class BStringRef;

   enum PrivateDataTag {
    PRIVATE_DATA
   };

private:
       BString(char* privateData, PrivateDataTag tag);


   status_t _MakeWritable();
   status_t _MakeWritable(int32 length, bool copy);
 static char* _Allocate(int32 length);
   char* _Resize(int32 length);
   void _Init(const char* src, int32 length);
   char* _Clone(const char* data, int32 length);
   char* _OpenAtBy(int32 offset, int32 length);
   char* _ShrinkAtBy(int32 offset, int32 length);


   void _SetLength(int32 length);
   bool _DoAppend(const char* string, int32 length);
   bool _DoPrepend(const char* string, int32 length);
   bool _DoInsert(const char* string, int32 offset,
        int32 length);


   int32 _ShortFindAfter(const char* string,
        int32 length) const;
   int32 _FindAfter(const char* string, int32 offset,
        int32 length) const;
   int32 _IFindAfter(const char* string, int32 offset,
        int32 length) const;
   int32 _FindBefore(const char* string, int32 offset,
        int32 length) const;
   int32 _IFindBefore(const char* string, int32 offset,
        int32 length) const;


   BString& _DoCharacterEscape(const char* string,
        const char* setOfCharsToEscape, char escapeChar);
   BString& _DoCharacterDeescape(const char* string,
        char escapeChar);


   BString& _DoReplace(const char* findThis,
        const char* replaceWith, int32 maxReplaceCount,
        int32 fromOffset, bool ignoreCase);
   void _ReplaceAtPositions(const PosVect* positions,
        int32 searchLength, const char* with,
        int32 withLength);

private:
   int32& _ReferenceCount();
   const int32& _ReferenceCount() const;
   bool _IsShareable() const;
   void _FreePrivateData();
   void _ReleasePrivateData();

   char* fPrivateData;
};



bool operator<(const char* a, const BString& b);
bool operator<=(const char* a, const BString& b);
bool operator==(const char* a, const BString& b);
bool operator>(const char* a, const BString& b);
bool operator>=(const char* a, const BString& b);
bool operator!=(const char* a, const BString& b);



int Compare(const BString& a, const BString& b);
int ICompare(const BString& a, const BString& b);
int Compare(const BString* a, const BString* b);
int ICompare(const BString* a, const BString* b);


inline int32
BString::Length() const
{


 return fPrivateData ? (*(((int32*)fPrivateData) - 1) & 0x7fffffff) : 0;
}


inline bool
BString::IsEmpty() const
{
 return !Length();
}


inline const char*
BString::String() const
{
 if (!fPrivateData)
  return "";
 return fPrivateData;
}


inline uint32
BString::HashValue() const
{
 return HashValue(String());
}


inline BString&
BString::SetTo(const char* string)
{
 return operator=(string);
}


inline char
BString::operator[](int32 index) const
{
 return fPrivateData[index];
}


inline char
BString::ByteAt(int32 index) const
{
 if (!fPrivateData || index < 0 || index >= Length())
  return 0;
 return fPrivateData[index];
}


inline BString&
BString::operator+=(const BString& string)
{
 _DoAppend(string.String(), string.Length());
 return *this;
}


inline BString&
BString::Append(const BString& string)
{
 _DoAppend(string.String(), string.Length());
 return *this;
}


inline BString&
BString::Append(const char* string)
{
 return operator+=(string);
}


inline bool
BString::operator==(const BString& string) const
{
 return strcmp(String(), string.String()) == 0;
}


inline bool
BString::operator<(const BString& string) const
{
 return strcmp(String(), string.String()) < 0;
}


inline bool
BString::operator<=(const BString& string) const
{
 return strcmp(String(), string.String()) <= 0;
}


inline bool
BString::operator>=(const BString& string) const
{
 return strcmp(String(), string.String()) >= 0;
}


inline bool
BString::operator>(const BString& string) const
{
 return strcmp(String(), string.String()) > 0;
}


inline bool
BString::operator!=(const BString& string) const
{
 return strcmp(String(), string.String()) != 0;
}


inline bool
BString::operator!=(const char* string) const
{
 return !operator==(string);
}


inline
BString::operator const char*() const
{
 return String();
}


inline bool
operator<(const char* str, const BString& string)
{
 return string > str;
}


inline bool
operator<=(const char* str, const BString& string)
{
 return string >= str;
}


inline bool
operator==(const char* str, const BString& string)
{
 return string == str;
}


inline bool
operator>(const char* str, const BString& string)
{
 return string < str;
}


inline bool
operator>=(const char* str, const BString& string)
{
 return string <= str;
}


inline bool
operator!=(const char* str, const BString& string)
{
 return string != str;
}


class BBitmap;
class BMessage;
class BPoint;
class BRect;
struct key_info {
 uint32 modifiers;
 uint8 key_states[16];
};

enum {
 B_BACKSPACE = 0x08,
 B_RETURN = 0x0a,
 B_ENTER = 0x0a,
 B_SPACE = 0x20,
 B_TAB = 0x09,
 B_ESCAPE = 0x1b,
 B_SUBSTITUTE = 0x1a,

 B_LEFT_ARROW = 0x1c,
 B_RIGHT_ARROW = 0x1d,
 B_UP_ARROW = 0x1e,
 B_DOWN_ARROW = 0x1f,

 B_INSERT = 0x05,
 B_DELETE = 0x7f,
 B_HOME = 0x01,
 B_END = 0x04,
 B_PAGE_UP = 0x0b,
 B_PAGE_DOWN = 0x0c,

 B_FUNCTION_KEY = 0x10,


 B_KATAKANA_HIRAGANA = 0xf2,
 B_HANKAKU_ZENKAKU = 0xf3,
 B_HANGUL = 0xf0,
 B_HANGUL_HANJA = 0xf1
};

enum {
 B_F1_KEY = 0x02,
 B_F2_KEY = 0x03,
 B_F3_KEY = 0x04,
 B_F4_KEY = 0x05,
 B_F5_KEY = 0x06,
 B_F6_KEY = 0x07,
 B_F7_KEY = 0x08,
 B_F8_KEY = 0x09,
 B_F9_KEY = 0x0a,
 B_F10_KEY = 0x0b,
 B_F11_KEY = 0x0c,
 B_F12_KEY = 0x0d,
 B_PRINT_KEY = 0x0e,
 B_SCROLL_KEY = 0x0f,
 B_PAUSE_KEY = 0x10
};

struct key_map {
 uint32 version;
 uint32 caps_key;
 uint32 scroll_key;
 uint32 num_key;
 uint32 left_shift_key;
 uint32 right_shift_key;
 uint32 left_command_key;
 uint32 right_command_key;
 uint32 left_control_key;
 uint32 right_control_key;
 uint32 left_option_key;
 uint32 right_option_key;
 uint32 menu_key;
 uint32 lock_settings;
 int32 control_map[128];
 int32 option_caps_shift_map[128];
 int32 option_caps_map[128];
 int32 option_shift_map[128];
 int32 option_map[128];
 int32 caps_shift_map[128];
 int32 caps_map[128];
 int32 shift_map[128];
 int32 normal_map[128];
 int32 acute_dead_key[32];
 int32 grave_dead_key[32];
 int32 circumflex_dead_key[32];
 int32 dieresis_dead_key[32];
 int32 tilde_dead_key[32];
 uint32 acute_tables;
 uint32 grave_tables;
 uint32 circumflex_tables;
 uint32 dieresis_tables;
 uint32 tilde_tables;
};

enum {
 B_CONTROL_TABLE = 0x00000001,
 B_OPTION_CAPS_SHIFT_TABLE = 0x00000002,
 B_OPTION_CAPS_TABLE = 0x00000004,
 B_OPTION_SHIFT_TABLE = 0x00000008,
 B_OPTION_TABLE = 0x00000010,
 B_CAPS_SHIFT_TABLE = 0x00000020,
 B_CAPS_TABLE = 0x00000040,
 B_SHIFT_TABLE = 0x00000080,
 B_NORMAL_TABLE = 0x00000100
};


enum {
 B_SHIFT_KEY = 0x00000001,
 B_COMMAND_KEY = 0x00000002,
 B_CONTROL_KEY = 0x00000004,
 B_CAPS_LOCK = 0x00000008,
 B_SCROLL_LOCK = 0x00000010,
 B_NUM_LOCK = 0x00000020,
 B_OPTION_KEY = 0x00000040,
 B_MENU_KEY = 0x00000080,
 B_LEFT_SHIFT_KEY = 0x00000100,
 B_RIGHT_SHIFT_KEY = 0x00000200,
 B_LEFT_COMMAND_KEY = 0x00000400,
 B_RIGHT_COMMAND_KEY = 0x00000800,
 B_LEFT_CONTROL_KEY = 0x00001000,
 B_RIGHT_CONTROL_KEY = 0x00002000,
 B_LEFT_OPTION_KEY = 0x00004000,
 B_RIGHT_OPTION_KEY = 0x00008000
};




struct mouse_map {
 uint32 button[16];
};

enum mode_mouse {
 B_NORMAL_MOUSE = 0,
 B_CLICK_TO_FOCUS_MOUSE = -1,
 B_FOCUS_FOLLOWS_MOUSE = 1
};

enum mode_focus_follows_mouse {
 B_NORMAL_FOCUS_FOLLOWS_MOUSE = 0,
 B_WARP_FOCUS_FOLLOWS_MOUSE = 1,
 B_INSTANT_WARP_FOCUS_FOLLOWS_MOUSE = 2
};




enum border_style {
 B_PLAIN_BORDER,
 B_FANCY_BORDER,
 B_NO_BORDER
};

enum orientation {
 B_HORIZONTAL,
 B_VERTICAL
};

enum button_width {
 B_WIDTH_AS_USUAL,
 B_WIDTH_FROM_WIDEST,
 B_WIDTH_FROM_LABEL
};

struct scroll_bar_info {
 bool proportional;
 bool double_arrows;
 int32 knob;
 int32 min_knob_size;
};

enum alignment {
 B_ALIGN_LEFT,
 B_ALIGN_RIGHT,
 B_ALIGN_CENTER,

 B_ALIGN_HORIZONTAL_CENTER = B_ALIGN_CENTER,

 B_ALIGN_HORIZONTAL_UNSET = -1L,
 B_ALIGN_USE_FULL_WIDTH = -2L
};

enum vertical_alignment {
 B_ALIGN_TOP = 0x10L,
 B_ALIGN_MIDDLE = 0x20,
 B_ALIGN_BOTTOM = 0x30,

 B_ALIGN_VERTICAL_CENTER = B_ALIGN_MIDDLE,

 B_ALIGN_VERTICAL_UNSET = -1L,
 B_ALIGN_NO_VERTICAL = B_ALIGN_VERTICAL_UNSET,
 B_ALIGN_USE_FULL_HEIGHT = -2L
};





enum {
 B_USE_DEFAULT_SPACING = -1002,
 B_USE_ITEM_SPACING = -1003,
 B_USE_ITEM_INSETS = B_USE_ITEM_SPACING,
 B_USE_HALF_ITEM_SPACING = -1004,
 B_USE_HALF_ITEM_INSETS = B_USE_HALF_ITEM_SPACING,
 B_USE_WINDOW_SPACING = -1005,
 B_USE_WINDOW_INSETS = B_USE_WINDOW_SPACING,
 B_USE_SMALL_SPACING = -1006,
 B_USE_SMALL_INSETS = B_USE_SMALL_SPACING,
 B_USE_CORNER_SPACING = -1007,
 B_USE_CORNER_INSETS = B_USE_CORNER_SPACING,
 B_USE_BIG_SPACING = -1008,
 B_USE_BIG_INSETS = B_USE_BIG_SPACING,
 B_USE_BORDER_SPACING = -1009,
 B_USE_BORDER_INSETS = B_USE_BORDER_SPACING,
};




enum join_mode {
 B_ROUND_JOIN = 0,
 B_MITER_JOIN,
 B_BEVEL_JOIN,
 B_BUTT_JOIN,
 B_SQUARE_JOIN
};

enum cap_mode {
 B_ROUND_CAP = B_ROUND_JOIN,
 B_BUTT_CAP = B_BUTT_JOIN,
 B_SQUARE_CAP = B_SQUARE_JOIN
};

const float B_DEFAULT_MITER_LIMIT = 10.0F;




enum {
 B_EVEN_ODD = 0,
 B_NONZERO
};




enum bitmap_tiling {
 B_TILE_BITMAP_X = 0x00000001,
 B_TILE_BITMAP_Y = 0x00000002,
 B_TILE_BITMAP = 0x00000003
};

enum overlay_options {
 B_OVERLAY_FILTER_HORIZONTAL = 0x00010000,
 B_OVERLAY_FILTER_VERTICAL = 0x00020000,
 B_OVERLAY_MIRROR = 0x00040000,
 B_OVERLAY_TRANSFER_CHANNEL = 0x00080000
};

enum bitmap_drawing_options {
 B_FILTER_BITMAP_BILINEAR = 0x00000100,

 B_WAIT_FOR_RETRACE = 0x00000800
};




enum color_which {
 B_NO_COLOR = 0,
 B_PANEL_BACKGROUND_COLOR = 1,
 B_PANEL_TEXT_COLOR = 10,
 B_DOCUMENT_BACKGROUND_COLOR = 11,
 B_DOCUMENT_TEXT_COLOR = 12,
 B_CONTROL_BACKGROUND_COLOR = 13,
 B_CONTROL_TEXT_COLOR = 14,
 B_CONTROL_BORDER_COLOR = 15,
 B_CONTROL_HIGHLIGHT_COLOR = 16,
 B_CONTROL_MARK_COLOR = 27,
 B_NAVIGATION_BASE_COLOR = 4,
 B_NAVIGATION_PULSE_COLOR = 17,
 B_SHINE_COLOR = 18,
 B_SHADOW_COLOR = 19,

 B_LINK_TEXT_COLOR = 33,
 B_LINK_HOVER_COLOR = 34,
 B_LINK_VISITED_COLOR = 35,
 B_LINK_ACTIVE_COLOR = 36,

 B_MENU_BACKGROUND_COLOR = 2,
 B_MENU_SELECTED_BACKGROUND_COLOR = 6,
 B_MENU_ITEM_TEXT_COLOR = 7,
 B_MENU_SELECTED_ITEM_TEXT_COLOR = 8,
 B_MENU_SELECTED_BORDER_COLOR = 9,

 B_LIST_BACKGROUND_COLOR = 28,
 B_LIST_SELECTED_BACKGROUND_COLOR = 29,
 B_LIST_ITEM_TEXT_COLOR = 30,
 B_LIST_SELECTED_ITEM_TEXT_COLOR = 31,

 B_SCROLL_BAR_THUMB_COLOR = 32,

 B_TOOL_TIP_BACKGROUND_COLOR = 20,
 B_TOOL_TIP_TEXT_COLOR = 21,

 B_STATUS_BAR_COLOR = 37,

 B_SUCCESS_COLOR = 100,
 B_FAILURE_COLOR = 101,

 B_WINDOW_TAB_COLOR = 3,
 B_WINDOW_TEXT_COLOR = 22,
 B_WINDOW_INACTIVE_TAB_COLOR = 23,
 B_WINDOW_INACTIVE_TEXT_COLOR = 24,

 B_WINDOW_BORDER_COLOR = 25,
 B_WINDOW_INACTIVE_BORDER_COLOR = 26,


 B_KEYBOARD_NAVIGATION_COLOR = B_NAVIGATION_BASE_COLOR,
 B_MENU_SELECTION_BACKGROUND_COLOR = B_MENU_SELECTED_BACKGROUND_COLOR,


 B_DESKTOP_COLOR = 5

};




const float B_LIGHTEN_MAX_TINT = 0.0f;
const float B_LIGHTEN_2_TINT = 0.385f;
const float B_LIGHTEN_1_TINT = 0.590f;

const float B_NO_TINT = 1.0f;

const float B_DARKEN_1_TINT = 1.147f;
const float B_DARKEN_2_TINT = 1.295f;
const float B_DARKEN_3_TINT = 1.407f;
const float B_DARKEN_4_TINT = 1.555f;
const float B_DARKEN_MAX_TINT = 2.0f;


const float B_DISABLED_LABEL_TINT = B_DARKEN_3_TINT;
const float B_HIGHLIGHT_BACKGROUND_TINT = B_DARKEN_2_TINT;
const float B_DISABLED_MARK_TINT = B_LIGHTEN_2_TINT;






enum {
 B_INACTIVE_ICON_BITMAP = 0x00,
 B_ACTIVE_ICON_BITMAP = 0x01,
 B_PARTIALLY_ACTIVATE_ICON_BITMAP = 0x02,


 B_DISABLED_ICON_BITMAP = 0x80,

};


enum {
 B_KEEP_ICON_BITMAP = 0x0001,

};


enum {
 B_TRIM_ICON_BITMAP = 0x0100,


 B_TRIM_ICON_BITMAP_KEEP_ASPECT = 0x0200,

 B_CREATE_ACTIVE_ICON_BITMAP = 0x0400,
 B_CREATE_PARTIALLY_ACTIVE_ICON_BITMAP = 0x0800,
 B_CREATE_DISABLED_ICON_BITMAPS = 0x1000,
};


status_t get_deskbar_frame(BRect* frame);

const color_map* system_colors();

status_t set_screen_space(int32 index, uint32 resolution,
     bool save = true);

status_t get_scroll_bar_info(scroll_bar_info* info);
status_t set_scroll_bar_info(scroll_bar_info* info);

status_t get_mouse_type(int32* type);
status_t get_mouse_type(const char* mouse_name, int32* type);
status_t set_mouse_type(const char* mouse_name, int32 type);
status_t get_mouse_map(mouse_map* map);
status_t set_mouse_map(mouse_map* map);
status_t get_click_speed(bigtime_t* speed);
status_t set_click_speed(bigtime_t speed);
status_t get_mouse_speed(int32* speed);
status_t get_mouse_speed(const char* mouse_name, int32* speed);
status_t set_mouse_speed(const char* mouse_name, int32 speed);
status_t get_mouse_acceleration(int32* speed);
status_t get_mouse_acceleration(const char* mouse_name, int32* speed);
status_t set_mouse_acceleration(const char* mouse_name, int32 speed);

status_t get_key_repeat_rate(int32* rate);
status_t set_key_repeat_rate(int32 rate);
status_t get_key_repeat_delay(bigtime_t* delay);
status_t set_key_repeat_delay(bigtime_t delay);

uint32 modifiers();
status_t get_key_info(key_info* info);
void get_key_map(key_map** _map, char** _keyBuffer);
status_t get_keyboard_id(uint16* _id);
status_t get_modifier_key(uint32 modifier, uint32 *key);
void set_modifier_key(uint32 modifier, uint32 key);
void set_keyboard_locks(uint32 modifiers);

rgb_color keyboard_navigation_color();

int32 count_workspaces();
void set_workspace_count(int32 count);
int32 current_workspace();
void activate_workspace(int32 workspace);

bigtime_t idle_time();

void run_select_printer_panel();
void run_add_printer_panel();
void run_be_about();

void set_focus_follows_mouse(bool follow);
bool focus_follows_mouse();

void set_mouse_mode(mode_mouse mode);
mode_mouse mouse_mode();

void set_focus_follows_mouse_mode(mode_focus_follows_mouse mode);
mode_focus_follows_mouse focus_follows_mouse_mode();

status_t get_mouse(BPoint* screenWhere, uint32* buttons);
status_t get_mouse_bitmap(BBitmap** bitmap, BPoint* hotspot);

void set_accept_first_click(bool acceptFirstClick);
bool accept_first_click();

rgb_color ui_color(color_which which);
const char* ui_color_name(color_which which);
color_which which_ui_color(const char* name);
void set_ui_color(const color_which& which, const rgb_color& color);
void set_ui_colors(const BMessage* colors);
rgb_color tint_color(rgb_color color, float tint);

extern "C" status_t _init_interface_kit_();
typedef int32 image_id;

typedef enum {
 B_APP_IMAGE = 1,
 B_LIBRARY_IMAGE,
 B_ADD_ON_IMAGE,
 B_SYSTEM_IMAGE
} image_type;

typedef struct {
 image_id id;
 image_type type;
 int32 sequence;
 int32 init_order;
 void (*init_routine)();
 void (*term_routine)();
 dev_t device;
 ino_t node;
 char name[(1024)];
 void *text;
 void *data;
 int32 text_size;
 int32 data_size;


 int32 api_version;
 int32 abi;
} image_info;



extern "C" {
void initialize_before(image_id self);
void initialize_after(image_id self);
void terminate_before(image_id self);
void terminate_after(image_id self);
thread_id load_image(int32 argc, const char **argv, const char **environ);
image_id load_add_on(const char *path);
status_t unload_add_on(image_id image);
status_t get_image_symbol(image_id image, const char *name, int32 symbolType,
    void **_symbolLocation);
status_t get_nth_image_symbol(image_id image, int32 n, char *nameBuffer,
    int32 *_nameLength, int32 *_symbolType, void **_symbolLocation);
void clear_caches(void *address, size_t length, uint32 flags);







status_t _get_image_info(image_id image, image_info *info, size_t size);
status_t _get_next_image_info(team_id team, int32 *cookie, image_info *info,
    size_t size);



}
       

namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;




  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__));
    terminate();
  }
}
namespace std
{




  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
}


       



extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}


extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{



  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;




  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}


class BDataIO {
public:
        BDataIO();
 virtual ~BDataIO();

 virtual ssize_t Read(void* buffer, size_t size);
 virtual ssize_t Write(const void* buffer, size_t size);

 virtual status_t Flush();

   status_t ReadExactly(void* buffer, size_t size,
         size_t* _bytesRead = __null);
   status_t WriteExactly(const void* buffer, size_t size,
         size_t* _bytesWritten = __null);

private:
        BDataIO(const BDataIO&);
   BDataIO& operator=(const BDataIO&);

 virtual void _ReservedDataIO2();
 virtual void _ReservedDataIO3();
 virtual void _ReservedDataIO4();
 virtual void _ReservedDataIO5();
 virtual void _ReservedDataIO6();
 virtual void _ReservedDataIO7();
 virtual void _ReservedDataIO8();
 virtual void _ReservedDataIO9();
 virtual void _ReservedDataIO10();
 virtual void _ReservedDataIO11();
 virtual void _ReservedDataIO12();

private:
   uint32 _reserved[2];
};


class BPositionIO : public BDataIO {
public:
        BPositionIO();
 virtual ~BPositionIO();


 virtual ssize_t Read(void* buffer, size_t size);
 virtual ssize_t Write(const void* buffer, size_t size);


 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size) = 0;
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size) = 0;

   status_t ReadAtExactly(off_t position, void* buffer,
         size_t size, size_t* _bytesRead = __null);
   status_t WriteAtExactly(off_t position,
         const void* buffer, size_t size,
         size_t* _bytesWritten = __null);

 virtual off_t Seek(off_t position, uint32 seekMode) = 0;
 virtual off_t Position() const = 0;

 virtual status_t SetSize(off_t size);
 virtual status_t GetSize(off_t* size) const;

private:
 virtual void _ReservedPositionIO2();
 virtual void _ReservedPositionIO3();
 virtual void _ReservedPositionIO4();
 virtual void _ReservedPositionIO5();
 virtual void _ReservedPositionIO6();
 virtual void _ReservedPositionIO7();
 virtual void _ReservedPositionIO8();
 virtual void _ReservedPositionIO9();
 virtual void _ReservedPositionIO10();
 virtual void _ReservedPositionIO11();
 virtual void _ReservedPositionIO12();

private:
   uint32 _reserved[2];
};


class BMemoryIO : public BPositionIO {
public:
        BMemoryIO(void* data, size_t length);
        BMemoryIO(const void* data, size_t length);
 virtual ~BMemoryIO();

 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size);
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size);

 virtual off_t Seek(off_t position, uint32 seekMode);
 virtual off_t Position() const;

 virtual status_t SetSize(off_t size);

private:
        BMemoryIO(const BMemoryIO&);
   BMemoryIO& operator=(const BMemoryIO&);

 virtual void _ReservedMemoryIO1();
 virtual void _ReservedMemoryIO2();

private:
   bool fReadOnly;
   char* fBuffer;
   size_t fLength;
   size_t fBufferSize;
   size_t fPosition;

   uint32 _reserved[1];
};


class BMallocIO : public BPositionIO {
public:
        BMallocIO();
 virtual ~BMallocIO();

 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size);
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size);

 virtual off_t Seek(off_t position, uint32 seekMode);
 virtual off_t Position() const;

 virtual status_t SetSize(off_t size);


   void SetBlockSize(size_t blockSize);

   const void* Buffer() const;
   size_t BufferLength() const;

private:
        BMallocIO(const BMallocIO&);
   BMallocIO& operator=(const BMallocIO&);

 virtual void _ReservedMallocIO1();
 virtual void _ReservedMallocIO2();

private:
   size_t fBlockSize;
   size_t fMallocSize;
   size_t fLength;
   char* fData;
   off_t fPosition;

   uint32 _reserved[1];
};
struct node_ref;
struct stat_beos;
class BVolume;


class BStatable {
public:

 virtual ~BStatable();


private:
 virtual status_t _GetStat(struct stat_beos* stat) const = 0;


public:
 virtual status_t GetStat(struct stat* stat) const = 0;

 bool IsFile() const;
 bool IsDirectory() const;
 bool IsSymLink() const;

 status_t GetNodeRef(node_ref* ref) const;

 status_t GetOwner(uid_t* owner) const;
 status_t SetOwner(uid_t owner);

 status_t GetGroup(gid_t* group) const;
 status_t SetGroup(gid_t group);

 status_t GetPermissions(mode_t* permissions) const;
 status_t SetPermissions(mode_t permissions);

 status_t GetSize(off_t* size) const;

 status_t GetModificationTime(time_t* mtime) const;
 status_t SetModificationTime(time_t mtime);

 status_t GetCreationTime(time_t* ctime) const;
 status_t SetCreationTime(time_t ctime);

 status_t GetAccessTime(time_t* atime) const;
 status_t SetAccessTime(time_t atime);

 status_t GetVolume(BVolume* volume) const;

 class Private;

private:
 friend class BEntry;
 friend class BNode;
 friend class Private;

 virtual void _OhSoStatable2();
 virtual void _OhSoStatable3();
 uint32 _reserved[4];

 virtual status_t set_stat(struct stat &st, uint32 what) = 0;
};


class BDirectory;
class BPath;


struct entry_ref {
        entry_ref();
        entry_ref(dev_t dev, ino_t dir,
         const char* name);
        entry_ref(const entry_ref& ref);
        ~entry_ref();

   status_t set_name(const char* name);

   bool operator==(const entry_ref& ref) const;
   bool operator!=(const entry_ref& ref) const;
   entry_ref& operator=(const entry_ref& ref);

   dev_t device;
   ino_t directory;
   char* name;
};


class BEntry : public BStatable {
public:
        BEntry();
        BEntry(const BDirectory* dir, const char* path,
         bool traverse = false);
        BEntry(const entry_ref* ref,
         bool traverse = false);
        BEntry(const char* path, bool traverse = false);
        BEntry(const BEntry& entry);
 virtual ~BEntry();

   status_t InitCheck() const;
   bool Exists() const;

   const char* Name() const;

 virtual status_t GetStat(struct stat* stat) const;

   status_t SetTo(const BDirectory* dir, const char* path,
           bool traverse = false);
   status_t SetTo(const entry_ref* ref,
         bool traverse = false);
   status_t SetTo(const char* path, bool traverse = false);
   void Unset();

   status_t GetRef(entry_ref* ref) const;
   status_t GetPath(BPath* path) const;
   status_t GetParent(BEntry* entry) const;
   status_t GetParent(BDirectory* dir) const;
   status_t GetName(char* buffer) const;

   status_t Rename(const char* path, bool clobber = false);
   status_t MoveTo(BDirectory* dir, const char* path = __null,
         bool clobber = false);
   status_t Remove();

   bool operator==(const BEntry& item) const;
   bool operator!=(const BEntry& item) const;

   BEntry& operator=(const BEntry& item);

private:
   friend class BDirectory;
   friend class BFile;
   friend class BNode;
   friend class BSymLink;

 virtual void _PennyEntry1();
 virtual void _PennyEntry2();
 virtual void _PennyEntry3();
 virtual void _PennyEntry4();
 virtual void _PennyEntry5();
 virtual void _PennyEntry6();


 virtual status_t set_stat(struct stat& stat, uint32 what);
   status_t _SetTo(int dir, const char* path,
         bool traverse);
   status_t _SetName(const char* name);

   status_t _Rename(BEntry& target, bool clobber);

   void _Dump(const char* name = __null);

   status_t _GetStat(struct stat* stat) const;
 virtual status_t _GetStat(struct stat_beos* stat) const;

private:
   int fDirFd;
   char* fName;
   status_t fCStatus;

   uint32 _reserved[4];
};


status_t get_ref_for_path(const char* path, entry_ref* ref);
bool operator<(const entry_ref& a, const entry_ref& b);
class BFlattenable {
public:
 virtual bool IsFixedSize() const = 0;
 virtual type_code TypeCode() const = 0;
 virtual ssize_t FlattenedSize() const = 0;
 virtual status_t Flatten(void* buffer, ssize_t size) const = 0;
 virtual bool AllowsTypeCode(type_code code) const;
 virtual status_t Unflatten(type_code code, const void* buffer,
         ssize_t size) = 0;

 virtual ~BFlattenable();

private:
   void _ReservedFlattenable1();
 virtual void _ReservedFlattenable2();
 virtual void _ReservedFlattenable3();
};

class BDirectory;
class BEntry;
class BString;
struct entry_ref;


struct node_ref {
 node_ref();
 node_ref(dev_t device, ino_t node);
 node_ref(const node_ref& other);

 bool operator==(const node_ref& other) const;
 bool operator!=(const node_ref& other) const;
 bool operator<(const node_ref& other) const;
 node_ref& operator=(const node_ref& other);

 dev_t device;
 ino_t node;
};


class BNode : public BStatable {
public:
        BNode();
        BNode(const entry_ref* ref);
        BNode(const BEntry* entry);
        BNode(const char* path);
        BNode(const BDirectory* dir, const char* path);
        BNode(const BNode& node);
 virtual ~BNode();

   status_t InitCheck() const;

 virtual status_t GetStat(struct stat* st) const;

   status_t SetTo(const entry_ref* ref);
   status_t SetTo(const BEntry* entry);
   status_t SetTo(const char* path);
   status_t SetTo(const BDirectory* dir, const char* path);
   void Unset();

   status_t Lock();
   status_t Unlock();

   status_t Sync();

   ssize_t WriteAttr(const char* name, type_code type,
         off_t offset, const void* buffer,
         size_t length);
   ssize_t ReadAttr(const char* name, type_code type,
         off_t offset, void* buffer,
         size_t length) const;
   status_t RemoveAttr(const char* name);
   status_t RenameAttr(const char* oldName,
         const char* newName);
   status_t GetAttrInfo(const char* name,
         struct attr_info* info) const;
   status_t GetNextAttrName(char* buffer);
   status_t RewindAttrs();
   status_t WriteAttrString(const char* name,
         const BString* data);
   status_t ReadAttrString(const char* name,
         BString* result) const;

   BNode& operator=(const BNode& node);
   bool operator==(const BNode& node) const;
   bool operator!=(const BNode& node) const;

   int Dup();


private:
 friend class BFile;
 friend class BDirectory;
 friend class BSymLink;

 virtual void _RudeNode1();
 virtual void _RudeNode2();
 virtual void _RudeNode3();
 virtual void _RudeNode4();
 virtual void _RudeNode5();
 virtual void _RudeNode6();

private:
   status_t set_fd(int fd);
 virtual void close_fd();
   void set_status(status_t newStatus);

   status_t _SetTo(int fd, const char* path, bool traverse);
   status_t _SetTo(const entry_ref* ref, bool traverse);

 virtual status_t set_stat(struct stat& stat, uint32 what);

   status_t _GetStat(struct stat* stat) const;
 virtual status_t _GetStat(struct stat_beos* stat) const;
   status_t InitAttrDir();

private:
   uint32 rudeData[4];
   int fFd;

   int fAttrFd;


   status_t fCStatus;

};
 typedef float float_t;
 typedef double double_t;
struct __exception;
extern "C" int matherr(struct __exception *);
struct __exception {





 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};
extern int signgam;



extern "C" {



extern float acosf(float x);
extern float acoshf(float x);
extern float asinf(float x);
extern float asinhf(float x);
extern float atan2f(float y, float x);
extern float atanf(float x);
extern float atanhf(float x);
extern float cbrtf(float x);
extern float ceilf(float x);
extern float copysignf(float x, float y);
extern float cosf(float x);
extern float coshf(float x);
extern float erfcf(float x);
extern float erff(float x);
extern float expf(float x);
extern float exp2f(float x);
extern float expm1f(float x);
extern float fabsf(float x);
extern float fdimf(float x, float y);
extern float floorf(float x);
extern float fmaf(float x, float y, float z);
extern float fmaxf(float x, float y);
extern float fminf(float x, float y);
extern float fmodf(float x, float y);
extern float frexpf(float x, int *_exponent);
extern float gammaf(float x);
extern float hypotf(float x, float y);
extern int ilogbf(float x);
extern float ldexpf(float x, int exponent);
extern float lgammaf(float x);
extern long long llrintf(float x);
extern long long llroundf(float x);
extern float log10f(float x);
extern float log1pf(float x);
extern float log2f(float x);
extern float logbf(float x);
extern float logf(float x);
extern long lrintf(float x);
extern long lroundf(float x);
extern float modff(float x, float *y);
extern float nanf(const char *tagp);
extern float nearbyintf(float x);
extern float nextafterf(float x, float y);
extern float nexttowardf(float x, long double y);
extern float powf(float x, float y);
extern float remainderf(float x, float y);
extern float remquof(float x, float y, int *quo);
extern float rintf(float x);
extern float roundf(float x);
extern float scalbf(float x, float n);
extern float scalblnf(float x, long n);
extern float scalbnf(float x, int n);
extern float sinf(float x);
extern float sinhf(float x);
extern float sqrtf(float x);
extern float tanf(float x);
extern float tanhf(float x);
extern float tgammaf(float x);
extern float truncf(float x);


extern double acos(double x);
extern double acosh(double x);
extern double asin(double x);
extern double asinh(double x);
extern double atan(double x);
extern double atan2(double x, double y);
extern double atanh(double x);
extern double cbrt(double x);
extern double ceil(double x);
extern double copysign(double x, double y);
extern double cos(double x);
extern double cosh(double x);
extern double erf(double x);
extern double erfc(double x);
extern double exp(double x);
extern double expm1(double x);
extern double exp2(double x);
extern double fabs(double x);
extern double fdim(double x, double y);
extern double floor(double x);
extern double fma(double x, double y, double z);
extern double fmax(double x, double y);
extern double fmin(double x, double y);
extern double fmod(double x, double y);
extern double frexp(double x, int *_exponent);
extern double gamma(double x);
extern double hypot(double x, double y);
extern int ilogb(double x);
extern double ldexp(double x, int exponent);
extern double lgamma(double x);
extern long long llrint(double x);
extern long long llround(double x);
extern double log(double x);
extern double log10(double x);
extern double log1p(double x);
extern double log2(double x);
extern double logb(double x);
extern long lrint(double x);
extern long lround(double x);
extern double modf(double x, double *y);
extern double nan(const char* tagp);
extern double nearbyint(double x);
extern double nextafter(double x, double y);
extern double nexttoward(double x, long double y);
extern double pow(double x, double y);
extern double remainder(double x, double y);
extern double remquo(double x, double y, int *quo);
extern double rint(double x);
extern double round(double x);
extern double scalb(double x, double y);
extern double scalbln(double x, long n);
extern double scalbn(double x, int y);
extern double sin(double x);
extern double sinh(double x);
extern double sqrt(double x);
extern double tan(double x);
extern double tanh(double x);
extern double tgamma(double x);
extern double trunc(double x);


extern long double acoshl(long double x);
extern long double acosl(long double x);
extern long double asinhl(long double x);
extern long double asinl(long double x);
extern long double atanhl(long double x);
extern long double atanl(long double x);
extern long double atan2l(long double y, long double x);
extern long double cbrtl(long double x);
extern long double ceill(long double x);
extern long double copysignl(long double x, long double y);
extern long double cosl(long double x);
extern long double coshl(long double x);
extern long double erfcl(long double x);
extern long double erfl(long double x);
extern long double expl(long double x);
extern long double expm1l(long double x);
extern long double exp2l(long double x);
extern long double fabsl(long double x);
extern long double fdiml(long double x, long double y);
extern long double floorl(long double x);
extern long double fmal(long double x, long double y, long double z);
extern long double fmaxl(long double x, long double y);
extern long double fminl(long double x, long double y);
extern long double fmodl(long double x, long double y);
extern long double frexpl(long double num, int *_exponent);
extern long double hypotl(long double x, long double y);
extern int ilogbl(long double x);
extern long double ldexpl(long double x, int exponent);
extern long double lgammal(long double x);
extern long long llrintl(long double x);
extern long long llroundl(long double x);
extern long double logbl(long double x);
extern long double logl(long double x);
extern long double log1pl(long double x);
extern long double log10l(long double x);
extern long double log2l(long double x);
extern long lrintl(long double x);
extern long lroundl(long double x);
extern long double modfl(long double value, long double *iptr);
extern long double nanl(const char* tagp);
extern long double nearbyintl(long double x);
extern long double nextafterl(long double x, long double y);
extern long double nexttowardl(long double x, long double y);
extern long double powl(long double x, long double y);
extern long double remainderl(long double x, long double y);
extern long double remquol(long double x, long double y, int *quo);
extern long double rintl(long double x);
extern long double roundl(long double x);
extern long double scalbnl(long double x, int n);
extern long double scalblnl(long double x, long n);
extern long double sinl(long double x);
extern long double sinhl(long double x);
extern long double sqrtl(long double x);
extern long double tanl(long double x);
extern long double tanhl(long double x);
extern long double tgammal(long double x);
extern long double truncl(long double x);


extern double j0(double x);
extern double j1(double x);
extern double jn(int x, double y);
extern double lgamma_r(double x, int *y);
extern double y0(double x);
extern double y1(double x);
extern double yn(int x, double y);


extern int isinff(float value);
extern int finitef(float value);
extern float dremf(float x, float y);
extern float significandf(float x);
extern int isnanf(float value);
extern double significand(double x);
extern double drem(double x, double y);
extern int finite(double x);
extern float j0f(float x);
extern float j1f(float x);
extern float jnf(int x, float y);
extern float y0f(float x);
extern float y1f(float x);
extern float ynf(int x, float y);
extern float lgammaf_r(float x, int *y);
}

class BRect;


class BPoint {
public:
   float x;
   float y;

        BPoint();
        BPoint(float x, float y);
        BPoint(const BPoint& p);

   BPoint& operator=(const BPoint& other);
   void Set(float x, float y);

   void ConstrainTo(BRect rect);
   void PrintToStream() const;

   BPoint operator-() const;
   BPoint operator+(const BPoint& other) const;
   BPoint operator-(const BPoint& other) const;
   BPoint& operator+=(const BPoint& other);
   BPoint& operator-=(const BPoint& other);

   bool operator!=(const BPoint& other) const;
   bool operator==(const BPoint& other) const;
};


extern const BPoint B_ORIGIN;



inline
BPoint::BPoint()
 :
 x(0.0f),
 y(0.0f)
{
}


inline
BPoint::BPoint(float x, float y)
 :
 x(x),
 y(y)
{
}


inline
BPoint::BPoint(const BPoint& other)
 :
 x(other.x),
 y(other.y)
{
}


inline BPoint&
BPoint::operator=(const BPoint& other)
{
 x = other.x;
 y = other.y;
 return *this;
}


inline void
BPoint::Set(float x, float y)
{
 this->x = x;
 this->y = y;
}
const float B_SIZE_UNSET = -2;
const float B_SIZE_UNLIMITED = 1024 * 1024 * 1024;


class BSize {
public:
   float width;
   float height;

 inline BSize();
 inline BSize(const BSize& other);
 inline BSize(float width, float height);

 inline float Width() const;
 inline float Height() const;

 inline void Set(float width, float height);
 inline void SetWidth(float width);
 inline void SetHeight(float height);

 inline int32 IntegerWidth() const;
 inline int32 IntegerHeight() const;

 inline bool IsWidthSet() const;
 inline bool IsHeightSet() const;

 inline bool operator==(const BSize& other) const;
 inline bool operator!=(const BSize& other) const;

 inline BSize& operator=(const BSize& other);
};


inline
BSize::BSize()
 : width(B_SIZE_UNSET),
   height(B_SIZE_UNSET)
{
}


inline
BSize::BSize(const BSize& other)
 : width(other.width),
   height(other.height)
{
}


inline
BSize::BSize(float width, float height)
 : width(width),
   height(height)
{
}


inline float
BSize::Width() const
{
 return width;
}


inline float
BSize::Height() const
{
 return height;
}


inline void
BSize::Set(float width, float height)
{
 this->width = width;
 this->height = height;
}


inline void
BSize::SetWidth(float width)
{
 this->width = width;
}


inline void
BSize::SetHeight(float height)
{
 this->height = height;
}


inline int32
BSize::IntegerWidth() const
{
 return (int32)width;
}


inline int32
BSize::IntegerHeight() const
{
 return (int32)height;
}


inline bool
BSize::IsWidthSet() const
{
 return width != B_SIZE_UNSET;
}


inline bool
BSize::IsHeightSet() const
{
 return height != B_SIZE_UNSET;
}


inline bool
BSize::operator==(const BSize& other) const
{
 return (width == other.width && height == other.height);
}


inline bool
BSize::operator!=(const BSize& other) const
{
 return !(*this == other);
}


inline BSize&
BSize::operator=(const BSize& other)
{
 width = other.width;
 height = other.height;
 return *this;
}


class BRect {
public:
   float left;
   float top;
   float right;
   float bottom;

        BRect();
        BRect(const BRect& other);
        BRect(float left, float top, float right,
         float bottom);
        BRect(BPoint leftTop, BPoint rightBottom);
        BRect(BPoint leftTop, BSize size);
        BRect(float side);

   BRect& operator=(const BRect& other);
   void Set(float left, float top, float right,
         float bottom);

   void PrintToStream() const;

   BPoint LeftTop() const;
   BPoint RightBottom() const;
   BPoint LeftBottom() const;
   BPoint RightTop() const;

   void SetLeftTop(const BPoint point);
   void SetRightBottom(const BPoint point);
   void SetLeftBottom(const BPoint point);
   void SetRightTop(const BPoint point);


   void InsetBy(BPoint inset);
   void InsetBy(float dx, float dy);
   void OffsetBy(BPoint delta);
   void OffsetBy(float dx, float dy);
   void OffsetTo(BPoint offset);
   void OffsetTo(float x, float y);


   BRect& InsetBySelf(BPoint inset);
   BRect& InsetBySelf(float dx, float dy);
   BRect InsetByCopy(BPoint inset) const;
   BRect InsetByCopy(float dx, float dy) const;
   BRect& OffsetBySelf(BPoint offset);
   BRect& OffsetBySelf(float dx, float dy);
   BRect OffsetByCopy(BPoint offset) const;
   BRect OffsetByCopy(float dx, float dy) const;
   BRect& OffsetToSelf(BPoint offset);
   BRect& OffsetToSelf(float x, float y);
   BRect OffsetToCopy(BPoint offset) const;
   BRect OffsetToCopy(float x, float y) const;


   bool operator==(BRect other) const;
   bool operator!=(BRect other) const;


   BRect operator&(BRect other) const;
   BRect operator|(BRect other) const;

   bool IsValid() const;
   float Width() const;
   int32 IntegerWidth() const;
   float Height() const;
   int32 IntegerHeight() const;
   BSize Size() const;

   bool Intersects(BRect rect) const;
   bool Contains(BPoint point) const;
   bool Contains(BRect rect) const;
};




inline BPoint
BRect::LeftTop() const
{
 return *(const BPoint*)&left;
}


inline BPoint
BRect::RightBottom() const
{
 return *(const BPoint*)&right;
}


inline BPoint
BRect::LeftBottom() const
{
 return BPoint(left, bottom);
}


inline BPoint
BRect::RightTop() const
{
 return BPoint(right, top);
}


inline
BRect::BRect()
 :
 left(0),
 top(0),
 right(-1),
 bottom(-1)
{
}


inline
BRect::BRect(float left, float top, float right, float bottom)
 :
 left(left),
 top(top),
 right(right),
 bottom(bottom)
{
}


inline
BRect::BRect(const BRect& other)
 :
 left(other.left),
 top(other.top),
 right(other.right),
 bottom(other.bottom)
{
}


inline
BRect::BRect(BPoint leftTop, BPoint rightBottom)
 :
 left(leftTop.x),
 top(leftTop.y),
 right(rightBottom.x),
 bottom(rightBottom.y)
{
}


inline
BRect::BRect(BPoint leftTop, BSize size)
 :
 left(leftTop.x),
 top(leftTop.y),
 right(leftTop.x + size.width),
 bottom(leftTop.y + size.height)
{
}


inline
BRect::BRect(float side)
 :
 left(0),
 top(0),
 right(side - 1),
 bottom(side - 1)
{
}


inline BRect&
BRect::operator=(const BRect& other)
{
 left = other.left;
 top = other.top;
 right = other.right;
 bottom = other.bottom;
 return *this;
}


inline void
BRect::Set(float left, float top, float right, float bottom)
{
 this->left = left;
 this->top = top;
 this->right = right;
 this->bottom = bottom;
}


inline bool
BRect::IsValid() const
{
 return left <= right && top <= bottom;
}


inline int32
BRect::IntegerWidth() const
{
 return (int32)ceil(right - left);
}


inline float
BRect::Width() const
{
 return right - left;
}


inline int32
BRect::IntegerHeight() const
{
 return (int32)ceil(bottom - top);
}


inline float
BRect::Height() const
{
 return bottom - top;
}


inline BSize
BRect::Size() const
{
 return BSize(right - left, bottom - top);
}



enum {
 B_AFFINE_TRANSFORM_TYPE = 'AMTX',
 B_ALIGNMENT_TYPE = 'ALGN',
 B_ANY_TYPE = 'ANYT',
 B_ATOM_TYPE = 'ATOM',
 B_ATOMREF_TYPE = 'ATMR',
 B_BOOL_TYPE = 'BOOL',
 B_CHAR_TYPE = 'CHAR',
 B_COLOR_8_BIT_TYPE = 'CLRB',
 B_DOUBLE_TYPE = 'DBLE',
 B_FLOAT_TYPE = 'FLOT',
 B_GRAYSCALE_8_BIT_TYPE = 'GRYB',
 B_INT16_TYPE = 'SHRT',
 B_INT32_TYPE = 'LONG',
 B_INT64_TYPE = 'LLNG',
 B_INT8_TYPE = 'BYTE',
 B_LARGE_ICON_TYPE = 'ICON',
 B_MEDIA_PARAMETER_GROUP_TYPE = 'BMCG',
 B_MEDIA_PARAMETER_TYPE = 'BMCT',
 B_MEDIA_PARAMETER_WEB_TYPE = 'BMCW',
 B_MESSAGE_TYPE = 'MSGG',
 B_MESSENGER_TYPE = 'MSNG',
 B_MIME_TYPE = 'MIME',
 B_MINI_ICON_TYPE = 'MICN',
 B_MONOCHROME_1_BIT_TYPE = 'MNOB',
 B_OBJECT_TYPE = 'OPTR',
 B_OFF_T_TYPE = 'OFFT',
 B_PATTERN_TYPE = 'PATN',
 B_POINTER_TYPE = 'PNTR',
 B_POINT_TYPE = 'BPNT',
 B_PROPERTY_INFO_TYPE = 'SCTD',
 B_RAW_TYPE = 'RAWT',
 B_RECT_TYPE = 'RECT',
 B_REF_TYPE = 'RREF',
 B_NODE_REF_TYPE = 'NREF',
 B_RGB_32_BIT_TYPE = 'RGBB',
 B_RGB_COLOR_TYPE = 'RGBC',
 B_SIZE_TYPE = 'SIZE',
 B_SIZE_T_TYPE = 'SIZT',
 B_SSIZE_T_TYPE = 'SSZT',
 B_STRING_TYPE = 'CSTR',
 B_STRING_LIST_TYPE = 'STRL',
 B_TIME_TYPE = 'TIME',
 B_UINT16_TYPE = 'USHT',
 B_UINT32_TYPE = 'ULNG',
 B_UINT64_TYPE = 'ULLG',
 B_UINT8_TYPE = 'UBYT',
 B_VECTOR_ICON_TYPE = 'VICN',
 B_XATTR_TYPE = 'XATR',
 B_NETWORK_ADDRESS_TYPE = 'NWAD',
 B_MIME_STRING_TYPE = 'MIMS',


 B_ASCII_TYPE = 'TEXT'

};



extern const char* B_URL_HTTP;

extern const char* B_URL_HTTPS;

extern const char* B_URL_FTP;

extern const char* B_URL_GOPHER;

extern const char* B_URL_MAILTO;

extern const char* B_URL_NEWS;

extern const char* B_URL_NNTP;

extern const char* B_URL_TELNET;

extern const char* B_URL_RLOGIN;

extern const char* B_URL_TN3270;

extern const char* B_URL_WAIS;

extern const char* B_URL_FILE;


class BAlignment;
class BBlockCache;
class BMessenger;
class BHandler;
class BString;
class BStringList;
struct entry_ref;
struct rgb_color;






enum {
 B_NO_SPECIFIER = 0,
 B_DIRECT_SPECIFIER = 1,
 B_INDEX_SPECIFIER,
 B_REVERSE_INDEX_SPECIFIER,
 B_RANGE_SPECIFIER,
 B_REVERSE_RANGE_SPECIFIER,
 B_NAME_SPECIFIER,
 B_ID_SPECIFIER,

 B_SPECIFIERS_END = 128

};


class BMessage {
public:
   uint32 what;

        BMessage();
        BMessage(uint32 what);
        BMessage(const BMessage& other);
 virtual ~BMessage();

   BMessage& operator=(const BMessage& other);


   status_t GetInfo(type_code typeRequested, int32 index,
         char** nameFound, type_code* typeFound,
         int32* countFound = __null) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         int32* countFound = __null) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         bool* fixedSize) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         int32* countFound, bool* fixedSize) const;

   int32 CountNames(type_code type) const;
   bool IsEmpty() const;
   bool IsSystem() const;
   bool IsReply() const;
   void PrintToStream() const;

   status_t Rename(const char* oldEntry,
         const char* newEntry);


   bool WasDelivered() const;
   bool IsSourceWaiting() const;
   bool IsSourceRemote() const;
   BMessenger ReturnAddress() const;
   const BMessage* Previous() const;
   bool WasDropped() const;
   BPoint DropPoint(BPoint* offset = __null) const;


   status_t SendReply(uint32 command,
         BHandler* replyTo = __null);
   status_t SendReply(BMessage* reply,
         BHandler* replyTo = __null,
         bigtime_t timeout = (9223372036854775807LL));
   status_t SendReply(BMessage* reply, BMessenger replyTo,
         bigtime_t timeout = (9223372036854775807LL));

   status_t SendReply(uint32 command,
         BMessage* replyToReply);
   status_t SendReply(BMessage* reply,
         BMessage* replyToReply,
         bigtime_t sendTimeout = (9223372036854775807LL),
         bigtime_t replyTimeout
          = (9223372036854775807LL));


   ssize_t FlattenedSize() const;
   status_t Flatten(char* buffer, ssize_t size) const;
   status_t Flatten(BDataIO* stream,
         ssize_t* size = __null) const;
   status_t Unflatten(const char* flatBuffer);
   status_t Unflatten(BDataIO* stream);


   status_t AddSpecifier(const char* property);
   status_t AddSpecifier(const char* property, int32 index);
   status_t AddSpecifier(const char* property, int32 index,
         int32 range);
   status_t AddSpecifier(const char* property,
         const char* name);
   status_t AddSpecifier(const BMessage* specifier);

   status_t SetCurrentSpecifier(int32 index);
   status_t GetCurrentSpecifier(int32* index,
         BMessage* specifier = __null,
         int32* what = __null,
         const char** property = __null) const;
   bool HasSpecifiers() const;
   status_t PopSpecifier();


   status_t AddAlignment(const char* name,
         const BAlignment& alignment);
   status_t AddRect(const char* name, BRect rect);
   status_t AddPoint(const char* name, BPoint point);
   status_t AddSize(const char* name, BSize size);
   status_t AddString(const char* name, const char* string);
   status_t AddString(const char* name,
         const BString& string);
   status_t AddStrings(const char* name,
         const BStringList& list);
   status_t AddInt8(const char* name, int8 value);
   status_t AddUInt8(const char* name, uint8 value);
   status_t AddInt16(const char* name, int16 value);
   status_t AddUInt16(const char* name, uint16 value);
   status_t AddInt32(const char* name, int32 value);
   status_t AddUInt32(const char* name, uint32 value);
   status_t AddInt64(const char* name, int64 value);
   status_t AddUInt64(const char* name, uint64 value);
   status_t AddBool(const char* name, bool value);
   status_t AddFloat(const char* name, float value);
   status_t AddDouble(const char* name, double value);
   status_t AddColor(const char* name, rgb_color value);
   status_t AddPointer(const char* name,
         const void* pointer);
   status_t AddMessenger(const char* name,
         BMessenger messenger);
   status_t AddRef(const char* name, const entry_ref* ref);
   status_t AddNodeRef(const char* name,
         const node_ref* ref);
   status_t AddMessage(const char* name,
         const BMessage* message);
   status_t AddFlat(const char* name, BFlattenable* object,
         int32 count = 1);
   status_t AddFlat(const char* name,
         const BFlattenable* object, int32 count = 1);
   status_t AddData(const char* name, type_code type,
         const void* data, ssize_t numBytes,
         bool isFixedSize = true, int32 count = 1);

   status_t Append(const BMessage& message);


   status_t RemoveData(const char* name, int32 index = 0);
   status_t RemoveName(const char* name);
   status_t MakeEmpty();


   status_t FindAlignment(const char* name,
         BAlignment* alignment) const;
   status_t FindAlignment(const char* name, int32 index,
         BAlignment* alignment) const;

   status_t FindRect(const char* name, BRect* rect) const;
   status_t FindRect(const char* name, int32 index,
         BRect* rect) const;
   status_t FindPoint(const char* name,
         BPoint* point) const;
   status_t FindPoint(const char* name, int32 index,
         BPoint* point) const;

   status_t FindSize(const char* name, BSize* size) const;
   status_t FindSize(const char* name, int32 index,
         BSize* size) const;

   status_t FindString(const char* name,
         const char** string) const;
   status_t FindString(const char* name, int32 index,
         const char** string) const;
   status_t FindString(const char* name,
         BString* string) const;
   status_t FindString(const char* name, int32 index,
         BString* string) const;
   status_t FindStrings(const char* name,
         BStringList* list) const;
   status_t FindInt8(const char* name, int8* value) const;
   status_t FindInt8(const char* name, int32 index,
         int8* value) const;
   status_t FindUInt8(const char* name, uint8* value) const;
   status_t FindUInt8(const char* name, int32 index,
         uint8* value) const;
   status_t FindInt16(const char* name, int16* value) const;
   status_t FindInt16(const char* name, int32 index,
         int16* value) const;
   status_t FindUInt16(const char* name,
         uint16* value) const;
   status_t FindUInt16(const char* name, int32 index,
         uint16* value) const;
   status_t FindInt32(const char* name, int32* value) const;
   status_t FindInt32(const char* name, int32 index,
         int32* value) const;
   status_t FindUInt32(const char* name,
         uint32* value) const;
   status_t FindUInt32(const char* name, int32 index,
         uint32* value) const;
   status_t FindInt64(const char* name, int64* value) const;
   status_t FindInt64(const char* name, int32 index,
         int64* value) const;
   status_t FindUInt64(const char* name,
         uint64* value) const;
   status_t FindUInt64(const char* name, int32 index,
         uint64* value) const;
   status_t FindBool(const char* name, bool* value) const;
   status_t FindBool(const char* name, int32 index,
         bool* value) const;
   status_t FindFloat(const char* name, float* value) const;
   status_t FindFloat(const char* name, int32 index,
         float* value) const;
   status_t FindDouble(const char* name,
         double* value) const;
   status_t FindDouble(const char* name, int32 index,
         double* value) const;
   status_t FindColor(const char* name,
         rgb_color* value) const;
   status_t FindColor(const char* name, int32 index,
         rgb_color* value) const;
   status_t FindPointer(const char* name,
         void** pointer) const;
   status_t FindPointer(const char* name, int32 index,
         void** pointer) const;
   status_t FindMessenger(const char* name,
         BMessenger* messenger) const;
   status_t FindMessenger(const char* name, int32 index,
         BMessenger* messenger) const;
   status_t FindRef(const char* name, entry_ref* ref) const;
   status_t FindRef(const char* name, int32 index,
         entry_ref* ref) const;
   status_t FindNodeRef(const char* name,
         node_ref* ref) const;
   status_t FindNodeRef(const char* name, int32 index,
         node_ref* ref) const;
   status_t FindMessage(const char* name,
         BMessage* message) const;
   status_t FindMessage(const char* name, int32 index,
         BMessage* message) const;
   status_t FindFlat(const char* name,
         BFlattenable* object) const;
   status_t FindFlat(const char* name, int32 index,
         BFlattenable* object) const;
   status_t FindData(const char* name, type_code type,
         const void** data, ssize_t* numBytes) const;
   status_t FindData(const char* name, type_code type,
         int32 index, const void** data,
         ssize_t* numBytes) const;


   status_t ReplaceAlignment(const char* name,
         const BAlignment& alignment);
   status_t ReplaceAlignment(const char* name, int32 index,
         const BAlignment& alignment);

   status_t ReplaceRect(const char* name, BRect rect);
   status_t ReplaceRect(const char* name, int32 index,
         BRect rect);

   status_t ReplacePoint(const char* name, BPoint aPoint);
   status_t ReplacePoint(const char* name, int32 index,
         BPoint aPoint);
   status_t ReplaceSize(const char* name, BSize aSize);
   status_t ReplaceSize(const char* name, int32 index,
         BSize aSize);

   status_t ReplaceString(const char* name,
         const char* string);
   status_t ReplaceString(const char* name, int32 index,
         const char* string);
   status_t ReplaceString(const char* name,
         const BString& string);
   status_t ReplaceString(const char* name, int32 index,
         const BString& string);
   status_t ReplaceInt8(const char* name, int8 value);
   status_t ReplaceInt8(const char* name, int32 index,
         int8 value);
   status_t ReplaceUInt8(const char* name, uint8 value);
   status_t ReplaceUInt8(const char* name, int32 index,
         uint8 value);
   status_t ReplaceInt16(const char* name, int16 value);
   status_t ReplaceInt16(const char* name, int32 index,
         int16 value);
   status_t ReplaceUInt16(const char* name, uint16 value);
   status_t ReplaceUInt16(const char* name, int32 index,
         uint16 value);
   status_t ReplaceInt32(const char* name, int32 value);
   status_t ReplaceInt32(const char* name, int32 index,
         int32 value);
   status_t ReplaceUInt32(const char* name, uint32 value);
   status_t ReplaceUInt32(const char* name, int32 index,
         uint32 value);
   status_t ReplaceInt64(const char* name, int64 value);
   status_t ReplaceInt64(const char* name, int32 index,
         int64 value);
   status_t ReplaceUInt64(const char* name, uint64 value);
   status_t ReplaceUInt64(const char* name, int32 index,
         uint64 value);
   status_t ReplaceBool(const char* name, bool aBoolean);
   status_t ReplaceBool(const char* name, int32 index,
         bool value);
   status_t ReplaceFloat(const char* name, float value);
   status_t ReplaceFloat(const char* name, int32 index,
         float value);
   status_t ReplaceDouble(const char* name, double value);
   status_t ReplaceDouble(const char* name, int32 index,
         double value);
   status_t ReplaceColor(const char* name,
         rgb_color value);
   status_t ReplaceColor(const char* name, int32 index,
         rgb_color value);
   status_t ReplacePointer(const char* name,
         const void* pointer);
   status_t ReplacePointer(const char* name, int32 index,
         const void* pointer);
   status_t ReplaceMessenger(const char* name,
         BMessenger messenger);
   status_t ReplaceMessenger(const char* name, int32 index,
         BMessenger messenger);
   status_t ReplaceRef(const char* name,
         const entry_ref* ref);
   status_t ReplaceRef(const char* name, int32 index,
         const entry_ref* ref);
   status_t ReplaceNodeRef(const char* name,
         const node_ref* ref);
   status_t ReplaceNodeRef(const char* name, int32 index,
         const node_ref* ref);
   status_t ReplaceMessage(const char* name,
         const BMessage* message);
   status_t ReplaceMessage(const char* name, int32 index,
         const BMessage* message);
   status_t ReplaceFlat(const char* name,
         BFlattenable* object);
   status_t ReplaceFlat(const char* name, int32 index,
         BFlattenable* object);
   status_t ReplaceData(const char* name, type_code type,
         const void* data, ssize_t numBytes);
   status_t ReplaceData(const char* name, type_code type,
         int32 index, const void* data,
         ssize_t numBytes);


   bool HasSameData(const BMessage& other,
         bool ignoreFieldOrder = true,
         bool deep = false) const;

   void* operator new(size_t size);
   void* operator new(size_t, void* pointer);
   void* operator new(size_t,
         const std::nothrow_t& noThrow);
   void operator delete(void* pointer, size_t size);


   bool HasAlignment(const char* name,
         int32 n = 0) const;
   bool HasRect(const char* name, int32 n = 0) const;
   bool HasPoint(const char* name, int32 n = 0) const;
   bool HasSize(const char* name, int32 n = 0) const;
   bool HasString(const char* name, int32 n = 0) const;
   bool HasInt8(const char* name, int32 n = 0) const;
   bool HasUInt8(const char* name, int32 n = 0) const;
   bool HasInt16(const char* name, int32 n = 0) const;
   bool HasUInt16(const char* name, int32 n = 0) const;
   bool HasInt32(const char* name, int32 n = 0) const;
   bool HasUInt32(const char* name, int32 n = 0) const;
   bool HasInt64(const char* name, int32 n = 0) const;
   bool HasUInt64(const char* name, int32 n = 0) const;
   bool HasBool(const char* name, int32 n = 0) const;
   bool HasFloat(const char* name, int32 n = 0) const;
   bool HasDouble(const char* name, int32 n = 0) const;
   bool HasColor(const char* name, int32 n = 0) const;
   bool HasPointer(const char* name, int32 n = 0) const;
   bool HasMessenger(const char* name,
         int32 n = 0) const;
   bool HasRef(const char* name, int32 n = 0) const;
   bool HasNodeRef(const char* name, int32 n = 0) const;
   bool HasMessage(const char* name, int32 n = 0) const;
   bool HasFlat(const char* name,
         const BFlattenable* object) const;
   bool HasFlat(const char* name, int32 n,
         const BFlattenable* object) const;
   bool HasData(const char* name, type_code ,
         int32 n = 0) const;
   BRect FindRect(const char* name, int32 n = 0) const;
   BPoint FindPoint(const char* name, int32 n = 0) const;
   const char* FindString(const char* name, int32 n = 0) const;
   int8 FindInt8(const char* name, int32 n = 0) const;
   int16 FindInt16(const char* name, int32 n = 0) const;
   int32 FindInt32(const char* name, int32 n = 0) const;
   int64 FindInt64(const char* name, int32 n = 0) const;
   bool FindBool(const char* name, int32 n = 0) const;
   float FindFloat(const char* name, int32 n = 0) const;
   double FindDouble(const char* name, int32 n = 0) const;


   bool GetBool(const char* name,
         bool defaultValue = false) const;
   bool GetBool(const char* name, int32 index,
         bool defaultValue) const;
   int8 GetInt8(const char* name,
         int8 defaultValue) const;
   int8 GetInt8(const char* name, int32 index,
         int8 defaultValue) const;
   uint8 GetUInt8(const char* name,
         uint8 defaultValue) const;
   uint8 GetUInt8(const char* name, int32 index,
         uint8 defaultValue) const;
   int16 GetInt16(const char* name,
         int16 defaultValue) const;
   int16 GetInt16(const char* name, int32 index,
         int16 defaultValue) const;
   uint16 GetUInt16(const char* name,
         uint16 defaultValue) const;
   uint16 GetUInt16(const char* name, int32 index,
         uint16 defaultValue) const;
   int32 GetInt32(const char* name,
         int32 defaultValue) const;
   int32 GetInt32(const char* name, int32 index,
         int32 defaultValue) const;
   uint32 GetUInt32(const char* name,
         uint32 defaultValue) const;
   uint32 GetUInt32(const char* name, int32 index,
         uint32 defaultValue) const;
   int64 GetInt64(const char* name,
         int64 defaultValue) const;
   int64 GetInt64(const char* name, int32 index,
         int64 defaultValue) const;
   uint64 GetUInt64(const char* name,
         uint64 defaultValue) const;
   uint64 GetUInt64(const char* name, int32 index,
         uint64 defaultValue) const;
   float GetFloat(const char* name,
         float defaultValue) const;
   float GetFloat(const char* name, int32 index,
         float defaultValue) const;
   double GetDouble(const char* name,
         double defaultValue) const;
   double GetDouble(const char* name, int32 index,
         double defaultValue) const;
   rgb_color GetColor(const char* name,
         rgb_color defaultValue) const;
   rgb_color GetColor(const char* name, int32 index,
         rgb_color defaultValue) const;
   const void* GetPointer(const char* name, int32 index,
         const void* defaultValue = __null) const;
   const void* GetPointer(const char* name,
         const void* defaultValue = __null) const;
   const char* GetString(const char* name,
         const char* defaultValue = __null) const;
   const char* GetString(const char* name, int32 index,
         const char* defaultValue) const;
   BAlignment GetAlignment(const char* name, int32 index,
         const BAlignment& defaultValue) const;
   BAlignment GetAlignment(const char* name,
         const BAlignment& defaultValue) const;
   BRect GetRect(const char* name, int32 index,
         const BRect& defaultValue) const;
   BRect GetRect(const char* name,
         const BRect& defaultValue) const;
   BPoint GetPoint(const char* name, int32 index,
         const BPoint& defaultValue) const;
   BPoint GetPoint(const char* name,
         const BPoint& defaultValue) const;
   BSize GetSize(const char* name, int32 index,
         const BSize& defaultValue) const;
   BSize GetSize(const char* name,
         const BSize& defaultValue) const;


   status_t SetBool(const char* name, bool value);
   status_t SetInt8(const char* name, int8 value);
   status_t SetUInt8(const char* name, uint8 value);
   status_t SetInt16(const char* name, int16 value);
   status_t SetUInt16(const char* name, uint16 value);
   status_t SetInt32(const char* name, int32 value);
   status_t SetUInt32(const char* name, uint32 value);
   status_t SetInt64(const char* name, int64 value);
   status_t SetUInt64(const char* name, uint64 value);
   status_t SetColor(const char* name, rgb_color value);
   status_t SetPointer(const char* name, const void* value);
   status_t SetString(const char* name, const char* string);
   status_t SetString(const char* name,
         const BString& string);
   status_t SetFloat(const char* name, float value);
   status_t SetDouble(const char* name, double value);
   status_t SetAlignment(const char* name,
         const BAlignment& value);
   status_t SetPoint(const char* name, const BPoint& value);
   status_t SetRect(const char* name, const BRect& value);
   status_t SetSize(const char* name, const BSize& value);
   status_t SetData(const char* name, type_code type,
         const void* data, ssize_t numBytes,
         bool fixedSize = true, int count = 1);

 class Private;
 struct message_header;
 struct field_header;

private:
 friend class Private;
 friend class BMessageQueue;

   status_t _InitCommon(bool initHeader);
   status_t _InitHeader();
   status_t _Clear();

   status_t _FlattenToArea(message_header** _header) const;
   status_t _CopyForWrite();
   status_t _Reference();
   status_t _Dereference();

   status_t _ValidateMessage();

   void _UpdateOffsets(uint32 offset, int32 change);
   status_t _ResizeData(uint32 offset, int32 change);

   uint32 _HashName(const char* name) const;
   status_t _FindField(const char* name, type_code type,
         field_header** _result) const;
   status_t _AddField(const char* name, type_code type,
         bool isFixedSize, field_header** _result);
   status_t _RemoveField(field_header* field);

   void _PrintToStream(const char* indent) const;

private:
        BMessage(BMessage* message);


 virtual void _ReservedMessage1();
 virtual void _ReservedMessage2();
 virtual void _ReservedMessage3();

   status_t _SendMessage(port_id port, team_id portOwner,
         int32 token, bigtime_t timeout,
         bool replyRequired,
         BMessenger& replyTo) const;
   status_t _SendMessage(port_id port, team_id portOwner,
         int32 token, BMessage* reply,
         bigtime_t sendTimeout,
         bigtime_t replyTimeout) const;
 static status_t _SendFlattenedMessage(void* data, int32 size,
         port_id port, int32 token,
         bigtime_t timeout);

 static void _StaticInit();
 static void _StaticReInitForkedChild();
 static void _StaticCleanup();
 static void _StaticCacheCleanup();
 static int32 _StaticGetCachedReplyPort();

private:
   message_header* fHeader;
   field_header* fFields;
   uint8* fData;

   uint32 fFieldsAvailable;
   size_t fDataAvailable;

   mutable BMessage* fOriginal;

   BMessage* fQueueLink;


   void* fArchivingPointer;

   uint32 fReserved[8];

   enum { sNumReplyPorts = 3 };
 static port_id sReplyPorts[sNumReplyPorts];
 static int32 sReplyPortInUse[sNumReplyPorts];
 static int32 sGetCachedReplyPort();

 static BBlockCache* sMsgCache;
};



class BMessage;


namespace BPrivate {
namespace Archiving {
 class BArchiveManager;
 class BUnarchiveManager;
}
}

using ::BPrivate::Archiving::BArchiveManager;
using ::BPrivate::Archiving::BUnarchiveManager;


class BArchivable {
public:
        BArchivable(BMessage* from);
        BArchivable();
 virtual ~BArchivable();

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* archive);

 virtual status_t Perform(perform_code d, void* arg);

 virtual status_t AllUnarchived(const BMessage* archive);
 virtual status_t AllArchived(BMessage* archive) const;

private:
 friend class BUnarchiveManager;

 virtual void _ReservedArchivable3();

   int32 fArchivingToken;
   uint32 _reserved;
};


class BArchiver {
public:
        BArchiver(BMessage* archive);
        ~BArchiver();

   status_t AddArchivable(const char* name,
         BArchivable* archivable, bool deep = true);

 inline status_t GetTokenForArchivable(BArchivable* archivable,
         int32& _token);
   status_t GetTokenForArchivable(BArchivable* archivable,
         bool deep, int32& _token);

   bool IsArchived(BArchivable* archivable);
   status_t Finish(status_t err = ((int)0));
   BMessage* ArchiveMessage() const;

private:
 friend class BArchivable;

        BArchiver();
        BArchiver(const BArchiver&);

   void RegisterArchivable(
         const BArchivable* archivable);

   BArchiveManager* fManager;
   BMessage* fArchive;
   bool fFinished;
   uint32 _reserved[2];
};


class BUnarchiver {
public:
   enum ownership_policy {
    B_ASSUME_OWNERSHIP,
    B_DONT_ASSUME_OWNERSHIP
   };

        BUnarchiver(const BMessage* archive);
        ~BUnarchiver();

 template<class T>
 inline status_t GetObject(int32 token, T*& object);

 template<class T>
   status_t GetObject(int32 token, ownership_policy owning,
         T*& object);

 template<class T>
 inline status_t FindObject(const char* name, T*& object);

 template<class T>
 inline status_t FindObject(const char* name,
         ownership_policy owning,
         T*& object);

 template<class T>
 inline status_t FindObject(const char* name,
         int32 index, T*& object);

 template<class T>
   status_t FindObject(const char* name, int32 index,
         ownership_policy owning, T*& object);

 inline status_t EnsureUnarchived(const char* name,
         int32 index = 0);
 inline status_t EnsureUnarchived(int32 token);

   bool IsInstantiated(int32 token);
   bool IsInstantiated(const char* name,
         int32 index = 0);

   status_t Finish(status_t err = ((int)0));
   const BMessage* ArchiveMessage() const;

   void AssumeOwnership(BArchivable* archivable);
   void RelinquishOwnership(BArchivable* archivable);

 static bool IsArchiveManaged(const BMessage* archive);
 static BMessage* PrepareArchive(BMessage*& archive);

 template<class T>
 static status_t InstantiateObject(BMessage* archive,
         T*& object);

private:
 friend class BArchivable;

        BUnarchiver();
        BUnarchiver(const BUnarchiver&);

   void RegisterArchivable(BArchivable* archivable);

 inline void _CallDebuggerIfManagerNull();

   BUnarchiveManager* fManager;
   const BMessage* fArchive;
   bool fFinished;
   uint32 _reserved[2];
};




typedef BArchivable* (*instantiation_func)(BMessage*);

BArchivable* instantiate_object(BMessage* from, image_id* id);
BArchivable* instantiate_object(BMessage* from);
bool validate_instantiation(BMessage* from, const char* className);

instantiation_func find_instantiation_func(const char* className,
 const char* signature);
instantiation_func find_instantiation_func(const char* className);
instantiation_func find_instantiation_func(BMessage* archive);


status_t
BArchiver::GetTokenForArchivable(BArchivable* archivable, int32& _token)
{
 return GetTokenForArchivable(archivable, true, _token);
}


template<>
status_t BUnarchiver::FindObject<BArchivable>(const char* name, int32 index,
 ownership_policy owning, BArchivable*& archivable);


template<class T>
status_t
BUnarchiver::FindObject(const char* name, int32 index,
 ownership_policy owning, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = FindObject(name, index, owning, interim);

 if (err == ((int)0) && interim) {
  object = dynamic_cast<T*>(interim);
  if (!object) {
   err = ((-0x7fffffff - 1) + 4);

   if (owning == B_ASSUME_OWNERSHIP)
    RelinquishOwnership(interim);
  }
 }
 return err;
}


template<>
status_t
BUnarchiver::GetObject<BArchivable>(int32 token,
 ownership_policy owning, BArchivable*& object);


template<class T>
status_t
BUnarchiver::GetObject(int32 token, ownership_policy owning, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = GetObject(token, owning, interim);

 if (err == ((int)0) && interim) {
  object = dynamic_cast<T*>(interim);
  if (!object) {
   err = ((-0x7fffffff - 1) + 4);

   if (owning == B_ASSUME_OWNERSHIP)
    RelinquishOwnership(interim);
  }
 }
 return err;
}


template<class T>
status_t
BUnarchiver::GetObject(int32 token, T*& object)
{
 return GetObject<T>(token, B_ASSUME_OWNERSHIP, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name, ownership_policy owning, T*& object)
{
 return FindObject(name, 0, owning, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name, T*& object)
{
 return FindObject<T>(name, 0, B_ASSUME_OWNERSHIP, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name,
 int32 index, T*& object)
{
 return FindObject(name, index, B_ASSUME_OWNERSHIP, object);
}


status_t
BUnarchiver::EnsureUnarchived(int32 token)
{
 BArchivable* dummy;
 return GetObject(token, B_DONT_ASSUME_OWNERSHIP, dummy);
}


status_t
BUnarchiver::EnsureUnarchived(const char* name, int32 index)
{
 BArchivable* dummy;
 return FindObject(name, index, B_DONT_ASSUME_OWNERSHIP, dummy);
}


template<>
status_t
BUnarchiver::InstantiateObject<BArchivable>(BMessage* from,
 BArchivable*& object);


template<class T>
status_t
BUnarchiver::InstantiateObject(BMessage* archive, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = InstantiateObject(archive, interim);
 if (err != ((int)0) || interim == __null)
  return err;

 object = dynamic_cast<T*>(interim);
 if (object == __null) {
  delete interim;
  return ((-0x7fffffff - 1) + 4);
 }

 return ((int)0);
}


class BLooper;
class BMessageFilter;
class BMessage;
class BMessenger;
class BList;



const uint32 B_OBSERVER_OBSERVE_ALL = 0xffffffff;

namespace BPrivate {
 class ObserverList;
}

class BHandler : public BArchivable {
public:
       BHandler(const char* name = __null);
 virtual ~BHandler();


       BHandler(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;


 virtual void MessageReceived(BMessage* message);
   BLooper* Looper() const;
   void SetName(const char* name);
   const char* Name() const;
 virtual void SetNextHandler(BHandler* handler);
   BHandler* NextHandler() const;


 virtual void AddFilter(BMessageFilter* filter);
 virtual bool RemoveFilter(BMessageFilter* filter);
 virtual void SetFilterList(BList* filters);
   BList* FilterList();

   bool LockLooper();
   status_t LockLooperWithTimeout(bigtime_t timeout);
   void UnlockLooper();


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
        BMessage* specifier, int32 what,
        const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);


   status_t StartWatching(BMessenger target, uint32 what);
   status_t StartWatchingAll(BMessenger target);
   status_t StopWatching(BMessenger target, uint32 what);
   status_t StopWatchingAll(BMessenger target);


   status_t StartWatching(BHandler* observer, uint32 what);
   status_t StartWatchingAll(BHandler* observer);
   status_t StopWatching(BHandler* observer, uint32 what);
   status_t StopWatchingAll(BHandler* observer);



 virtual status_t Perform(perform_code d, void* arg);


 virtual void SendNotices(uint32 what,
        const BMessage* notice = __null);
   bool IsWatched() const;

private:
 typedef BArchivable _inherited;
 friend inline int32 _get_object_token_(const BHandler* );
 friend class BLooper;
 friend class BMessageFilter;

 virtual void _ReservedHandler2();
 virtual void _ReservedHandler3();
 virtual void _ReservedHandler4();

   void _InitData(const char* name);
   BPrivate::ObserverList* _ObserverList();

       BHandler(const BHandler&);
   BHandler& operator=(const BHandler&);
   void SetLooper(BLooper* looper);

   int32 fToken;
   char* fName;
   BLooper* fLooper;
   BHandler* fNextHandler;
   BList* fFilters;
   BPrivate::ObserverList* fObserverList;
   uint32 _reserved[3];
};
class BList {
public:
        BList(int32 count = 20);
        BList(const BList& other);
 virtual ~BList();

   BList& operator=(const BList& other);
   bool operator==(const BList& other) const;
   bool operator!=(const BList& other) const;


   bool AddItem(void* item, int32 index);
   bool AddItem(void* item);
   bool AddList(const BList* list, int32 index);
   bool AddList(const BList* list);

   bool RemoveItem(void* item);
   void* RemoveItem(int32 index);
   bool RemoveItems(int32 index, int32 count);
   bool ReplaceItem(int32 index, void* item);

   void MakeEmpty();


   void SortItems(int (*compareFunc)(const void*,
         const void*));
   bool SwapItems(int32 indexA, int32 indexB);
   bool MoveItem(int32 from, int32 to);


   void* ItemAt(int32 index) const;
   void* FirstItem() const;
   void* ItemAtFast(int32 index) const;


   void* LastItem() const;
   void* Items() const;


   bool HasItem(void* item) const;
   bool HasItem(const void* item) const;
   int32 IndexOf(void* item) const;
   int32 IndexOf(const void* item) const;
   int32 CountItems() const;
   bool IsEmpty() const;


   void DoForEach(bool (*func)(void* item));
   void DoForEach(bool (*func)(void* item,
         void* arg2), void* arg2);

private:
 virtual void _ReservedList1();
 virtual void _ReservedList2();

   bool _ResizeArray(int32 count);

private:
   void** fObjectList;
   int32 fPhysicalSize;
   int32 fItemCount;
   int32 fBlockSize;
   int32 fResizeThreshold;

   uint32 _reserved[1];
};



class BMessage;
class BMessageQueue;
namespace BPrivate {
 class BDirectMessageTarget;
 class BLooperList;
}





class BLooper : public BHandler {
public:
       BLooper(const char* name = __null,
        int32 priority = 10,
        int32 portCapacity
         = 200);
 virtual ~BLooper();


       BLooper(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;


   status_t PostMessage(uint32 command);
   status_t PostMessage(BMessage* message);
   status_t PostMessage(uint32 command, BHandler* handler,
        BHandler* replyTo = __null);
   status_t PostMessage(BMessage* message, BHandler* handler,
        BHandler* replyTo = __null);

 virtual void DispatchMessage(BMessage* message,
        BHandler* handler);
 virtual void MessageReceived(BMessage* message);
   BMessage* CurrentMessage() const;
   BMessage* DetachCurrentMessage();
   void DispatchExternalMessage(BMessage* message,
        BHandler* handler, bool& _detached);
   BMessageQueue* MessageQueue() const;
   bool IsMessageWaiting() const;


   void AddHandler(BHandler* handler);
   bool RemoveHandler(BHandler* handler);
   int32 CountHandlers() const;
   BHandler* HandlerAt(int32 index) const;
   int32 IndexOf(BHandler* handler) const;

   BHandler* PreferredHandler() const;
   void SetPreferredHandler(BHandler* handler);


 virtual thread_id Run();
   void Loop();
 virtual void Quit();
 virtual bool QuitRequested();
   bool Lock();
   void Unlock();
   bool IsLocked() const;
   status_t LockWithTimeout(bigtime_t timeout);
   thread_id Thread() const;
   team_id Team() const;
 static BLooper* LooperForThread(thread_id thread);


   thread_id LockingThread() const;
   int32 CountLocks() const;
   int32 CountLockRequests() const;
   sem_id Sem() const;


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
        BMessage* specifier, int32 what,
        const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);


 virtual void AddCommonFilter(BMessageFilter* filter);
 virtual bool RemoveCommonFilter(BMessageFilter* filter);
 virtual void SetCommonFilterList(BList* filters);
   BList* CommonFilterList() const;


 virtual status_t Perform(perform_code d, void* arg);

protected:

   BMessage* MessageFromPort(bigtime_t = (9223372036854775807LL));

private:
 typedef BHandler _inherited;
 friend class BWindow;
 friend class BApplication;
 friend class BMessenger;
 friend class BView;
 friend class BHandler;
 friend class ::BPrivate::BLooperList;
 friend port_id _get_looper_port_(const BLooper* );

 virtual void _ReservedLooper1();
 virtual void _ReservedLooper2();
 virtual void _ReservedLooper3();
 virtual void _ReservedLooper4();
 virtual void _ReservedLooper5();
 virtual void _ReservedLooper6();

       BLooper(const BLooper&);
   BLooper& operator=(const BLooper&);

       BLooper(int32 priority, port_id port,
        const char* name);

   status_t _PostMessage(BMessage* msg, BHandler* handler,
        BHandler* reply_to);

 static status_t _Lock(BLooper* loop, port_id port,
        bigtime_t timeout);
 static status_t _LockComplete(BLooper* loop, int32 old,
        thread_id this_tid, sem_id sem,
        bigtime_t timeout);
   void _InitData(const char* name, int32 priority,
        port_id port, int32 capacity);
   void AddMessage(BMessage* msg);
   void _AddMessagePriv(BMessage* msg);
 static status_t _task0_(void* arg);

   void* ReadRawFromPort(int32* code,
        bigtime_t timeout = (9223372036854775807LL));
   BMessage* ReadMessageFromPort(
        bigtime_t timeout = (9223372036854775807LL));
 virtual BMessage* ConvertToMessage(void* raw, int32 code);
 virtual void task_looper();
   void _QuitRequested(BMessage* msg);
   bool AssertLocked() const;
   BHandler* _TopLevelFilter(BMessage* msg, BHandler* target);
   BHandler* _HandlerFilter(BMessage* msg, BHandler* target);
   BHandler* _ApplyFilters(BList* list, BMessage* msg,
        BHandler* target);
   void check_lock();
   BHandler* resolve_specifier(BHandler* target, BMessage* msg);
   void UnlockFully();

   ::BPrivate::BDirectMessageTarget* fDirectTarget;
   BMessage* fLastMessage;
   port_id fMsgPort;
   int32 fAtomicCount;
   sem_id fLockSem;
   int32 fOwnerCount;
   thread_id fOwner;
   thread_id fThread;
   addr_t fCachedStack;
   int32 fInitPriority;
   BHandler* fPreferred;
   BList fHandlers;
   BList* fCommonFilters;
   bool fTerminating;
   bool fRunCalled;
   bool fOwnsPort;
   uint32 _reserved[11];
};






typedef enum {
 B_SWAP_HOST_TO_LENDIAN,
 B_SWAP_HOST_TO_BENDIAN,
 B_SWAP_LENDIAN_TO_HOST,
 B_SWAP_BENDIAN_TO_HOST,
 B_SWAP_ALWAYS
} swap_action;
extern "C" {


extern status_t swap_data(type_code type, void *data, size_t length,
 swap_action action);
extern bool is_type_swapped(type_code type);


extern double __swap_double(double arg);
extern float __swap_float(float arg);
}



class BHandler;
class BLooper;

class BMessenger {
public:
         BMessenger();
         BMessenger(const char* signature,
          team_id team = -1,
          status_t* result = __null);
         BMessenger(const BHandler* handler,
          const BLooper* looper = __null,
          status_t* result = __null);
         BMessenger(const BMessenger& other);
         ~BMessenger();



   bool IsTargetLocal() const;
   BHandler* Target(BLooper **looper) const;
   bool LockTarget() const;
   status_t LockTargetWithTimeout(
          bigtime_t timeout) const;



   status_t SendMessage(uint32 command,
          BHandler* replyTo = __null) const;
   status_t SendMessage(BMessage* message,
          BHandler* replyTo = __null,
          bigtime_t timeout
           = (9223372036854775807LL)) const;
   status_t SendMessage(BMessage* message,
          BMessenger replyTo,
          bigtime_t timeout
           = (9223372036854775807LL)) const;
   status_t SendMessage(uint32 command,
          BMessage* reply) const;
   status_t SendMessage(BMessage* message,
          BMessage* reply,
          bigtime_t deliveryTimeout
           = (9223372036854775807LL),
          bigtime_t replyTimeout
           = (9223372036854775807LL)) const;



   status_t SetTo(const char* signature,
          team_id team = -1);
   status_t SetTo(const BHandler* handler,
          const BLooper* looper = __null);

   BMessenger& operator=(const BMessenger& other);
   bool operator==(const BMessenger& other) const;

   bool IsValid() const;
   team_id Team() const;

   uint32 HashValue() const;



 class Private;

private:
 friend class Private;

   void _SetTo(team_id team, port_id port,
          int32 token);
   void _InitData(const char* signature,
          team_id team, status_t* result);
   void _InitData(const BHandler* handler,
          const BLooper *looper,
          status_t* result);

private:
   port_id fPort;
   int32 fHandlerToken;
   team_id fTeam;

   int32 _reserved[3];
};

bool operator<(const BMessenger& a, const BMessenger& b);
bool operator!=(const BMessenger& a, const BMessenger& b);




class BCursor;
class BList;
class BLocker;
class BMessageRunner;
class BResources;
class BServer;
class BWindow;

struct app_info;


namespace BPrivate {
 class PortLink;
 class ServerMemoryAllocator;
}


class BApplication : public BLooper {
public:
        BApplication(const char* signature);
        BApplication(const char* signature,
         status_t* error);
 virtual ~BApplication();


        BApplication(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;

   status_t InitCheck() const;


 virtual thread_id Run();
 virtual void Quit();
 virtual bool QuitRequested();
 virtual void Pulse();
 virtual void ReadyToRun();
 virtual void MessageReceived(BMessage* message);
 virtual void ArgvReceived(int32 argc, char** argv);
 virtual void AppActivated(bool active);
 virtual void RefsReceived(BMessage* message);
 virtual void AboutRequested();


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
         BMessage* specifier, int32 form,
         const char* property);


   void ShowCursor();
   void HideCursor();
   void ObscureCursor();
   bool IsCursorHidden() const;
   void SetCursor(const void* cursor);
   void SetCursor(const BCursor* cursor,
         bool sync = true);

   int32 CountWindows() const;
   BWindow* WindowAt(int32 index) const;

   int32 CountLoopers() const;
   BLooper* LooperAt(int32 index) const;
   bool IsLaunching() const;
   const char* Signature() const;
   status_t GetAppInfo(app_info* info) const;
 static BResources* AppResources();

 virtual void DispatchMessage(BMessage* message,
         BHandler* handler);
   void SetPulseRate(bigtime_t rate);



   status_t RegisterLooper(BLooper* looper);
   status_t UnregisterLooper(BLooper* looper);


 virtual status_t GetSupportedSuites(BMessage* data);



 virtual status_t Perform(perform_code d, void* arg);

 class Private;

private:
 typedef BLooper _inherited;

 friend class Private;
 friend class BServer;

        BApplication(const char* signature,
         const char* looperName, port_id port,
         bool initGUI, status_t* error);
        BApplication(uint32 signature);
        BApplication(const BApplication&);
   BApplication& operator=(const BApplication&);

 virtual void _ReservedApplication1();
 virtual void _ReservedApplication2();
 virtual void _ReservedApplication3();
 virtual void _ReservedApplication4();
 virtual void _ReservedApplication5();
 virtual void _ReservedApplication6();
 virtual void _ReservedApplication7();
 virtual void _ReservedApplication8();

 virtual bool ScriptReceived(BMessage* msg, int32 index,
         BMessage* specifier, int32 form,
         const char* property);
   void _InitData(const char* signature, bool initGUI,
         status_t* error);
   port_id _GetPort(const char* signature);
   void BeginRectTracking(BRect r, bool trackWhole);
   void EndRectTracking();
   status_t _SetupServerAllocator();
   status_t _InitGUIContext();
   status_t _ConnectToServer();
   void _ReconnectToServer();
   bool _QuitAllWindows(bool force);
   bool _WindowQuitLoop(bool quitFilePanels,
         bool force);
   void _ArgvReceived(BMessage* message);

   uint32 InitialWorkspace();
   int32 _CountWindows(bool includeMenus) const;
   BWindow* _WindowAt(uint32 index,
         bool includeMenus) const;

 static void _InitAppResources();

private:
 static BResources* sAppResources;

   const char* fAppName;
   ::BPrivate::PortLink* fServerLink;
   ::BPrivate::ServerMemoryAllocator* fServerAllocator;

   void* fCursorData;
   bigtime_t fPulseRate;
   uint32 fInitialWorkspace;
   BMessageRunner* fPulseRunner;
   status_t fInitError;
   void* fServerReadOnlyMemory;
   uint32 _reserved[12];

   bool fReadyToRunCalled;
};




extern BApplication* be_app;
extern BMessenger be_app_messenger;
class BAffineTransform : public BFlattenable {
public:




 static constexpr double kDefaultEpsilon = 1e-14;


public:
         BAffineTransform();
         BAffineTransform(double sx, double shy,
          double shx, double sy, double tx,
          double ty);
         BAffineTransform(
          const BAffineTransform& copyFrom);
 virtual ~BAffineTransform();


 virtual bool IsFixedSize() const;
 virtual type_code TypeCode() const;
 virtual ssize_t FlattenedSize() const;
 virtual status_t Flatten(void* buffer,
          ssize_t size) const;
 virtual status_t Unflatten(type_code code,
          const void* buffer, ssize_t size);


 static BAffineTransform AffineTranslation(double x, double y);
 static BAffineTransform AffineRotation(double angle);
 static BAffineTransform AffineScaling(double x, double y);
 static BAffineTransform AffineScaling(double scale);
 static BAffineTransform AffineShearing(double x, double y);


 inline void Apply(double* x, double* y) const;
 inline void ApplyInverse(double* x, double* y) const;

   BPoint Apply(const BPoint& point) const;
   BPoint ApplyInverse(const BPoint& point) const;

   void Apply(BPoint* point) const;
   void ApplyInverse(BPoint* point) const;

   void Apply(BPoint* points, uint32 count) const;
   void ApplyInverse(BPoint* points,
          uint32 count) const;


 inline const BAffineTransform& TranslateBy(double x, double y);
   const BAffineTransform& TranslateBy(const BPoint& delta);

 inline const BAffineTransform& PreTranslateBy(double x, double y);

   BAffineTransform TranslateByCopy(double x, double y) const;
   BAffineTransform TranslateByCopy(const BPoint& delta) const;




 inline const BAffineTransform& RotateBy(double angle);
   const BAffineTransform& RotateBy(const BPoint& center,
          double angle);

 inline const BAffineTransform& PreRotateBy(double angleRadians);

   BAffineTransform RotateByCopy(double angle) const;
   BAffineTransform RotateByCopy(const BPoint& center,
          double angle) const;




 inline const BAffineTransform& ScaleBy(double scale);
   const BAffineTransform& ScaleBy(const BPoint& center,
          double scale);
 inline const BAffineTransform& ScaleBy(double x, double y);
   const BAffineTransform& ScaleBy(const BPoint& center, double x,
          double y);
   const BAffineTransform& ScaleBy(const BPoint& scale);
   const BAffineTransform& ScaleBy(const BPoint& center,
          const BPoint& scale);

 inline const BAffineTransform& PreScaleBy(double x, double y);

   BAffineTransform ScaleByCopy(double scale) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          double scale) const;
   BAffineTransform ScaleByCopy(double x, double y) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          double x, double y) const;
   BAffineTransform ScaleByCopy(const BPoint& scale) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          const BPoint& scale) const;

   const BAffineTransform& SetScale(double scale);
   const BAffineTransform& SetScale(double x, double y);


 inline const BAffineTransform& ShearBy(double x, double y);
   const BAffineTransform& ShearBy(const BPoint& center, double x,
          double y);
   const BAffineTransform& ShearBy(const BPoint& shear);
   const BAffineTransform& ShearBy(const BPoint& center,
          const BPoint& shear);

   BAffineTransform ShearByCopy(double x, double y) const;
   BAffineTransform ShearByCopy(const BPoint& center,
          double x, double y) const;
   BAffineTransform ShearByCopy(const BPoint& shear) const;
   BAffineTransform ShearByCopy(const BPoint& center,
          const BPoint& shear) const;




 inline const BAffineTransform& Multiply(const BAffineTransform& other);
   const BAffineTransform& PreMultiply(const BAffineTransform& other);
 inline const BAffineTransform& MultiplyInverse(
          const BAffineTransform& other);
 inline const BAffineTransform& PreMultiplyInverse(
          const BAffineTransform& other);


 inline BAffineTransform& operator=(
          const BAffineTransform& copyFrom);

 inline bool operator==(
          const BAffineTransform& other) const;
 inline bool operator!=(
          const BAffineTransform& other) const;

 inline const BAffineTransform& operator*=(const BAffineTransform& other);
 inline const BAffineTransform& operator/=(const BAffineTransform& other);

 inline BAffineTransform operator*(
          const BAffineTransform& other) const;
 inline BAffineTransform operator/(
          const BAffineTransform& other) const;

 inline BAffineTransform operator~() const;


   bool IsValid(double epsilon
          = kDefaultEpsilon) const;
   bool IsIdentity(double epsilon
          = kDefaultEpsilon) const;
   bool IsDilation(double epsilon
          = kDefaultEpsilon) const;
   bool IsEqual(const BAffineTransform& other,
          double epsilon
           = kDefaultEpsilon) const;

   const BAffineTransform& Invert();
   const BAffineTransform& FlipX();
   const BAffineTransform& FlipY();
   const BAffineTransform& Reset();

 inline double Determinant() const;
 inline double InverseDeterminant() const;
   void GetTranslation(double* tx,
          double* ty) const;
   double Rotation() const;
   double Scale() const;
   void GetScale(double* sx, double* sy) const;
   void GetScaleAbs(double* sx,
          double* sy) const;
   bool GetAffineParameters(double* translationX,
          double* translationY, double* rotation,
          double* scaleX, double* scaleY,
          double* shearX, double* shearY) const;

public:
   double sx;
   double shy;
   double shx;
   double sy;
   double tx;
   double ty;
};


extern const BAffineTransform B_AFFINE_IDENTITY_TRANSFORM;





inline void
BAffineTransform::Apply(double* x, double* y) const
{
 double tmp = *x;
 *x = tmp * sx + *y * shx + tx;
 *y = tmp * shy + *y * sy + ty;
}


inline void
BAffineTransform::ApplyInverse(double* x, double* y) const
{
 double d = InverseDeterminant();
 double a = (*x - tx) * d;
 double b = (*y - ty) * d;
 *x = a * sy - b * shx;
 *y = b * sx - a * shy;
}





inline const BAffineTransform&
BAffineTransform::TranslateBy(double x, double y)
{
 tx += x;
 ty += y;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreTranslateBy(double x, double y)
{
 tx += x * sx + y * shx;
 ty += x * shy + y * sy;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::RotateBy(double angle)
{
 double ca = cos(angle);
 double sa = sin(angle);
 double t0 = sx * ca - shy * sa;
 double t2 = shx * ca - sy * sa;
 double t4 = tx * ca - ty * sa;
 shy = sx * sa + shy * ca;
 sy = shx * sa + sy * ca;
 ty = tx * sa + ty * ca;
 sx = t0;
 shx = t2;
 tx = t4;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreRotateBy(double angle)
{
 double ca = cos(angle);
 double sa = sin(angle);
 double newSx = sx * ca + shx * sa;
 double newSy = -shy * sa + sy * ca;
 shy = shy * ca + sy * sa;
 shx = -sx * sa + shx * ca;
 sx = newSx;
 sy = newSy;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ScaleBy(double x, double y)
{
 double mm0 = x;

 double mm3 = y;
 sx *= mm0;
 shx *= mm0;
 tx *= mm0;
 shy *= mm3;
 sy *= mm3;
 ty *= mm3;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ScaleBy(double s)
{
 double m = s;

 sx *= m;
 shx *= m;
 tx *= m;
 shy *= m;
 sy *= m;
 ty *= m;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreScaleBy(double x, double y)
{
 sx *= x;
 shx *= y;
 shy *= x;
 sy *= y;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ShearBy(double x, double y)
{
 BAffineTransform shearTransform = AffineShearing(x, y);
 return PreMultiply(shearTransform);
}





inline const BAffineTransform&
BAffineTransform::Multiply(const BAffineTransform& other)
{
 BAffineTransform t(other);
 return *this = t.PreMultiply(*this);
}


inline const BAffineTransform&
BAffineTransform::MultiplyInverse(const BAffineTransform& other)
{
 BAffineTransform t(other);
 t.Invert();
 return Multiply(t);
}


inline const BAffineTransform&
BAffineTransform::PreMultiplyInverse(const BAffineTransform& other)
{
 BAffineTransform t(other);
 t.Invert();
 return *this = t.Multiply(*this);
}





inline BAffineTransform&
BAffineTransform::operator=(const BAffineTransform& other)
{
 sx = other.sx;
 shy = other.shy;
 shx = other.shx;
 sy = other.sy;
 tx = other.tx;
 ty = other.ty;
 return *this;
}

inline bool
BAffineTransform::operator==(const BAffineTransform& other) const
{
 return IsEqual(other);
}

inline bool
BAffineTransform::operator!=(const BAffineTransform& other) const
{
 return !IsEqual(other);
}


inline const BAffineTransform&
BAffineTransform::operator*=(const BAffineTransform& other)
{
 return Multiply(other);
}


inline const BAffineTransform&
BAffineTransform::operator/=(const BAffineTransform& other)
{
 return MultiplyInverse(other);
}


inline BAffineTransform
BAffineTransform::operator*(const BAffineTransform& other) const
{
 return BAffineTransform(*this).Multiply(other);
}


inline BAffineTransform
BAffineTransform::operator/(const BAffineTransform& other) const
{
 return BAffineTransform(*this).MultiplyInverse(other);
}


inline BAffineTransform
BAffineTransform::operator~() const
{
 BAffineTransform result(*this);
 return result.Invert();
}





inline double
BAffineTransform::Determinant() const
{
 return sx * sy - shy * shx;
}


inline double
BAffineTransform::InverseDeterminant() const
{
 return 1.0 / (sx * sy - shy * shx);
}
class BAlignment {
public:
   alignment horizontal;
   vertical_alignment vertical;

 inline BAlignment();
 inline BAlignment(const BAlignment& other);
 inline BAlignment(alignment horizontal,
         vertical_alignment vertical);

 inline alignment Horizontal() const;
 inline vertical_alignment Vertical() const;

   float RelativeHorizontal() const;
   float RelativeVertical() const;

 inline void SetHorizontal(alignment horizontal);
 inline void SetVertical(vertical_alignment vertical);

 inline bool IsHorizontalSet() const;
 inline bool IsVerticalSet() const;

 inline bool operator==(const BAlignment& other) const;
 inline bool operator!=(const BAlignment& other) const;

 inline BAlignment& operator=(const BAlignment& other);
};



inline
BAlignment::BAlignment()
 : horizontal(B_ALIGN_HORIZONTAL_UNSET),
   vertical(B_ALIGN_VERTICAL_UNSET)
{
}


inline
BAlignment::BAlignment(const BAlignment& other)
 : horizontal(other.horizontal),
   vertical(other.vertical)
{
}


inline
BAlignment::BAlignment(alignment horizontal, vertical_alignment vertical)
 : horizontal(horizontal),
   vertical(vertical)
{
}


inline alignment
BAlignment::Horizontal() const
{
 return horizontal;
}


inline vertical_alignment
BAlignment::Vertical() const
{
 return vertical;
}


inline void
BAlignment::SetHorizontal(alignment horizontal)
{
 this->horizontal = horizontal;
}


inline void
BAlignment::SetVertical(vertical_alignment vertical)
{
 this->vertical = vertical;
}


inline bool
BAlignment::IsHorizontalSet() const
{
 return (horizontal != B_ALIGN_HORIZONTAL_UNSET);
}


inline bool
BAlignment::IsVerticalSet() const
{
 return (vertical != B_ALIGN_VERTICAL_UNSET);
}


inline bool
BAlignment::operator==(const BAlignment& other) const
{
 return (horizontal == other.horizontal && vertical == other.vertical);
}


inline bool
BAlignment::operator!=(const BAlignment& other) const
{
 return !(*this == other);
}


inline BAlignment&
BAlignment::operator=(const BAlignment& other)
{
 horizontal = other.horizontal;
 vertical = other.vertical;
 return *this;
}
class BPoint;




typedef char font_family[63 + 1];
typedef char font_style[63 + 1];



enum {
 B_CHAR_SPACING = 0,
 B_STRING_SPACING = 1,
 B_BITMAP_SPACING = 2,
 B_FIXED_SPACING = 3
};


enum font_direction {
 B_FONT_LEFT_TO_RIGHT = 0,
 B_FONT_RIGHT_TO_LEFT = 1
};



enum {
 B_DISABLE_ANTIALIASING = 0x00000001,
 B_FORCE_ANTIALIASING = 0x00000002
};



enum {
 B_NO_TRUNCATION = ~0U,
 B_TRUNCATE_END = 0,
 B_TRUNCATE_BEGINNING = 1,
 B_TRUNCATE_MIDDLE = 2,
 B_TRUNCATE_SMART = 3
};



enum {
 B_UNICODE_UTF8 = 0,
 B_ISO_8859_1 = 1,
 B_ISO_8859_2 = 2,
 B_ISO_8859_3 = 3,
 B_ISO_8859_4 = 4,
 B_ISO_8859_5 = 5,
 B_ISO_8859_6 = 6,
 B_ISO_8859_7 = 7,
 B_ISO_8859_8 = 8,
 B_ISO_8859_9 = 9,
 B_ISO_8859_10 = 10,
 B_MACINTOSH_ROMAN = 11
};



enum {
 B_HAS_TUNED_FONT = 0x0001,
 B_IS_FIXED = 0x0002
};



enum {
 B_ITALIC_FACE = 0x0001,
 B_UNDERSCORE_FACE = 0x0002,
 B_NEGATIVE_FACE = 0x0004,
 B_OUTLINED_FACE = 0x0008,
 B_STRIKEOUT_FACE = 0x0010,
 B_BOLD_FACE = 0x0020,
 B_REGULAR_FACE = 0x0040,

 B_CONDENSED_FACE = 0x0080,
 B_LIGHT_FACE = 0x0100,
 B_HEAVY_FACE = 0x0200,
};


enum font_metric_mode {
 B_SCREEN_METRIC = 0,
 B_PRINTING_METRIC = 1
};


enum font_file_format {
 B_TRUETYPE_WINDOWS = 0,
 B_POSTSCRIPT_TYPE1_WINDOWS = 1
};


class unicode_block {
public:
 inline unicode_block();
 inline unicode_block(uint64 block2, uint64 block1);

 inline bool Includes(const unicode_block& block) const;
 inline unicode_block operator&(const unicode_block& block) const;
 inline unicode_block operator|(const unicode_block& block) const;
 inline unicode_block& operator=(const unicode_block& block);
 inline bool operator==(const unicode_block& block) const;
 inline bool operator!=(const unicode_block& block) const;

private:
 uint64 fData[2];
};


struct unicode_block_range {
 uint32 start;
 uint32 end;
 const unicode_block& block;

 uint32 Count() const { return end + 1 - start; }
};


struct edge_info {
 float left;
 float right;
};


struct font_height {
 float ascent;
 float descent;
 float leading;
};


struct escapement_delta {
 float nonspace;
 float space;
};


struct font_cache_info {
 int32 sheared_font_penalty;
 int32 rotated_font_penalty;
 float oversize_threshold;
 int32 oversize_penalty;
 int32 cache_size;
 float spacing_size_threshold;
};


struct tuned_font_info {
 float size;
 float shear;
 float rotation;
 uint32 flags;
 uint16 face;
};


class BShape;
class BString;
class BFontPrivate;


class BFont {
public:
        BFont();
        BFont(const BFont& font);
        BFont(const BFont* font);

   status_t SetFamilyAndStyle(const font_family family,
         const font_style style);
   void SetFamilyAndStyle(uint32 code);
   status_t SetFamilyAndFace(const font_family family,
         uint16 face);

   void SetSize(float size);
   void SetShear(float shear);
   void SetRotation(float rotation);
   void SetFalseBoldWidth(float width);
   void SetSpacing(uint8 spacing);
   void SetEncoding(uint8 encoding);
   void SetFace(uint16 face);
   void SetFlags(uint32 flags);

   void GetFamilyAndStyle(font_family* family,
         font_style* style) const;
   uint32 FamilyAndStyle() const;
   float Size() const;
   float Shear() const;
   float Rotation() const;
   float FalseBoldWidth() const;
   uint8 Spacing() const;
   uint8 Encoding() const;
   uint16 Face() const;
   uint32 Flags() const;

   font_direction Direction() const;
   bool IsFixed() const;
   bool IsFullAndHalfFixed() const;
   BRect BoundingBox() const;
   unicode_block Blocks() const;
   bool IncludesBlock(uint32 start, uint32 end) const;
   font_file_format FileFormat() const;

   int32 CountTuned() const;
   void GetTunedInfo(int32 index,
         tuned_font_info* info) const;

   void TruncateString(BString* inOut, uint32 mode,
         float width) const;
   void GetTruncatedStrings(const char* stringArray[],
         int32 numStrings, uint32 mode, float width,
         BString resultArray[]) const;
   void GetTruncatedStrings(const char* stringArray[],
         int32 numStrings, uint32 mode,
         float width, char* resultArray[]) const;

   float StringWidth(const char* string) const;
   float StringWidth(const char* string,
         int32 length) const;
   void GetStringWidths(const char* stringArray[],
         const int32 lengthArray[],
         int32 numStrings,
         float widthArray[]) const;

   void GetEscapements(const char charArray[],
         int32 numChars,
         float escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         float escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         BPoint escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         BPoint escapementArray[],
         BPoint offsetArray[]) const;

   void GetEdges(const char charArray[],
         int32 numBytes,
         edge_info edgeArray[]) const;
   void GetHeight(font_height* height) const;

   void GetBoundingBoxesAsGlyphs(
         const char charArray[], int32 numChars,
         font_metric_mode mode,
         BRect boundingBoxArray[]) const;
   void GetBoundingBoxesAsString(
         const char charArray[], int32 numChars,
         font_metric_mode mode,
         escapement_delta* delta,
         BRect boundingBoxArray[]) const;
   void GetBoundingBoxesForStrings(
         const char* stringArray[],
         int32 numStrings, font_metric_mode mode,
         escapement_delta deltas[],
         BRect boundingBoxArray[]) const;

   void GetGlyphShapes(const char charArray[],
         int32 numChars,
         BShape* glyphShapeArray[]) const;

   void GetHasGlyphs(const char charArray[],
         int32 numChars,
         bool hasArray[]) const;

   BFont& operator=(const BFont& font);
   bool operator==(const BFont& font) const;
   bool operator!=(const BFont& font) const;

   void PrintToStream() const;

   status_t LoadFont(const char* path);
   status_t LoadFont(const area_id fontAreaID,
         size_t size = 0, size_t offset = 0);
   status_t UnloadFont();

private:
  friend void _init_global_fonts_();

   void _GetExtraFlags() const;
   void _GetBoundingBoxes(const char charArray[],
         int32 numChars, font_metric_mode mode,
         bool string_escapement,
         escapement_delta* delta,
         BRect boundingBoxArray[],
         bool asString) const;

private:
   uint16 fFamilyID;
   uint16 fStyleID;
   float fSize;
   float fShear;
   float fRotation;
   float fFalseBoldWidth;
   uint8 fSpacing;
   uint8 fEncoding;
   uint16 fFace;
   uint32 fFlags;
 mutable font_height fHeight;
 mutable uint32 fExtraFlags;

   uint32 _reserved[1];
};




extern const BFont* be_plain_font;
extern const BFont* be_bold_font;
extern const BFont* be_fixed_font;

int32 count_font_families(void);
status_t get_font_family(int32 index, font_family* name,
 uint32* flags = __null);

int32 count_font_styles(font_family name);
status_t get_font_style(font_family family, int32 index, font_style* name,
 uint32* flags = __null);
status_t get_font_style(font_family family, int32 index, font_style* name,
 uint16* face, uint32* flags = __null);
bool update_font_families(bool checkOnly);






unicode_block::unicode_block()
{
 fData[0] = fData[1] = 0LL;
}


unicode_block::unicode_block(uint64 block2, uint64 block1)
{
 fData[0] = block1;
 fData[1] = block2;
}


bool
unicode_block::Includes(const unicode_block& block) const
{
 return (fData[0] & block.fData[0]) == block.fData[0]
  && (fData[1] & block.fData[1]) == block.fData[1];
}


unicode_block
unicode_block::operator&(const unicode_block& block) const
{
 unicode_block result;
 result.fData[0] = fData[0] & block.fData[0];
 result.fData[1] = fData[1] & block.fData[1];

 return result;
}


unicode_block
unicode_block::operator|(const unicode_block& block) const
{
 unicode_block result;
 result.fData[0] = fData[0] | block.fData[0];
 result.fData[1] = fData[1] | block.fData[1];

 return result;
}


unicode_block&
unicode_block::operator=(const unicode_block& block)
{
 fData[0] = block.fData[0];
 fData[1] = block.fData[1];

 return *this;
}


bool
unicode_block::operator==(const unicode_block& block) const
{
 return fData[0] == block.fData[0] && fData[1] == block.fData[1];
}


bool
unicode_block::operator!=(const unicode_block& block) const
{
 return fData[0] != block.fData[0] || fData[1] != block.fData[1];
}



class BDataIO;
class BMessage;
class BRect;
class BGradient : public BArchivable {
public:
 enum Type {
  TYPE_LINEAR = 0,
  TYPE_RADIAL,
  TYPE_RADIAL_FOCUS,
  TYPE_DIAMOND,
  TYPE_CONIC,
  TYPE_NONE
 };

 struct ColorStop {
  ColorStop(const rgb_color c, float o);
  ColorStop(uint8 r, uint8 g, uint8 b, uint8 a, float o);
  ColorStop(const ColorStop& other);
  ColorStop();

  bool operator!=(const ColorStop& other) const;

  rgb_color color;
  float offset;
 };

public:
        BGradient();
        BGradient(const BGradient& other);
        BGradient(BMessage* archive);
 virtual ~BGradient();

   status_t Archive(BMessage* into,
         bool deep = true) const;

   BGradient& operator=(const BGradient& other);

   bool operator==(const BGradient& other) const;
   bool operator!=(const BGradient& other) const;
   bool ColorStopsAreEqual(
         const BGradient& other) const;

   void SetColorStops(const BGradient& other);

   int32 AddColor(const rgb_color& color,
         float offset);
   bool AddColorStop(const ColorStop& colorStop,
         int32 index);

   bool RemoveColor(int32 index);

   bool SetColorStop(int32 index,
         const ColorStop& colorStop);
   bool SetColor(int32 index, const rgb_color& color);
   bool SetOffset(int32 index, float offset);

   int32 CountColorStops() const;
   ColorStop* ColorStopAt(int32 index) const;
   ColorStop* ColorStopAtFast(int32 index) const;
   ColorStop* ColorStops() const;
   void SortColorStopsByOffset();

   Type GetType() const
         { return fType; }

   void MakeEmpty();

   status_t Flatten(BDataIO* stream) const;
 static status_t Unflatten(BGradient *&output, BDataIO* stream);

private:
 friend class BGradientLinear;
 friend class BGradientRadial;
 friend class BGradientRadialFocus;
 friend class BGradientDiamond;
 friend class BGradientConic;

   union {
    struct {
     float x1, y1, x2, y2;
    } linear;
    struct {
     float cx, cy, radius;
    } radial;
    struct {
     float cx, cy, fx, fy, radius;
    } radial_focus;
    struct {
     float cx, cy;
    } diamond;
    struct {
     float cx, cy, angle;
    } conic;
   } fData;

   BList fColorStops;
   Type fType;
};






enum {
 B_PRIMARY_MOUSE_BUTTON = (1 << ((1) - 1)),
 B_SECONDARY_MOUSE_BUTTON = (1 << ((2) - 1)),
 B_TERTIARY_MOUSE_BUTTON = (1 << ((3) - 1))
};


enum {
 B_ENTERED_VIEW = 0,
 B_INSIDE_VIEW,
 B_EXITED_VIEW,
 B_OUTSIDE_VIEW
};


enum {
 B_POINTER_EVENTS = 0x00000001,
 B_KEYBOARD_EVENTS = 0x00000002
};


enum {
 B_LOCK_WINDOW_FOCUS = 0x00000001,
 B_SUSPEND_VIEW_FOCUS = 0x00000002,
 B_NO_POINTER_HISTORY = 0x00000004,

 B_FULL_POINTER_HISTORY = 0x00000008



};

enum rect_tracking_style {
 B_TRACK_WHOLE_RECT,
 B_TRACK_RECT_CORNER
};


enum set_font_mask {
 B_FONT_FAMILY_AND_STYLE = 0x00000001,
 B_FONT_SIZE = 0x00000002,
 B_FONT_SHEAR = 0x00000004,
 B_FONT_ROTATION = 0x00000008,
 B_FONT_SPACING = 0x00000010,
 B_FONT_ENCODING = 0x00000020,
 B_FONT_FACE = 0x00000040,
 B_FONT_FLAGS = 0x00000080,
 B_FONT_FALSE_BOLD_WIDTH = 0x00000100,
 B_FONT_ALL = 0x000001FF
};

typedef enum {
 B_CURRENT_STATE_COORDINATES,
 B_PREVIOUS_STATE_COORDINATES,
 B_VIEW_COORDINATES,
 B_PARENT_VIEW_DRAW_COORDINATES,
 B_PARENT_VIEW_COORDINATES,
 B_WINDOW_COORDINATES,
 B_SCREEN_COORDINATES
} coordinate_space;


const uint32 B_FULL_UPDATE_ON_RESIZE = 0x80000000UL;
const uint32 _B_RESERVED1_ = 0x40000000UL;
const uint32 B_WILL_DRAW = 0x20000000UL;
const uint32 B_PULSE_NEEDED = 0x10000000UL;
const uint32 B_NAVIGABLE_JUMP = 0x08000000UL;
const uint32 B_FRAME_EVENTS = 0x04000000UL;
const uint32 B_NAVIGABLE = 0x02000000UL;
const uint32 B_SUBPIXEL_PRECISE = 0x01000000UL;
const uint32 B_DRAW_ON_CHILDREN = 0x00800000UL;
const uint32 B_INPUT_METHOD_AWARE = 0x00400000UL;
const uint32 B_SCROLL_VIEW_AWARE = 0x00200000UL;
const uint32 B_SUPPORTS_LAYOUT = 0x00100000UL;
const uint32 B_INVALIDATE_AFTER_LAYOUT = 0x00080000UL;
const uint32 B_TRANSPARENT_BACKGROUND = 0x00040000UL;



const uint32 _VIEW_TOP_ = 1UL;
const uint32 _VIEW_LEFT_ = 2UL;
const uint32 _VIEW_BOTTOM_ = 3UL;
const uint32 _VIEW_RIGHT_ = 4UL;
const uint32 _VIEW_CENTER_ = 5UL;



const uint32 B_FOLLOW_NONE = 0;
const uint32 B_FOLLOW_ALL_SIDES = (((_VIEW_TOP_) << 12) | ((_VIEW_LEFT_) << 8) | ((_VIEW_BOTTOM_) << 4) | (_VIEW_RIGHT_))
                                      ;
const uint32 B_FOLLOW_ALL = B_FOLLOW_ALL_SIDES;

const uint32 B_FOLLOW_LEFT = (((0) << 12) | ((_VIEW_LEFT_) << 8) | ((0) << 4) | (_VIEW_LEFT_));
const uint32 B_FOLLOW_RIGHT = (((0) << 12) | ((_VIEW_RIGHT_) << 8) | ((0) << 4) | (_VIEW_RIGHT_));
const uint32 B_FOLLOW_LEFT_RIGHT = (((0) << 12) | ((_VIEW_LEFT_) << 8) | ((0) << 4) | (_VIEW_RIGHT_));
const uint32 B_FOLLOW_H_CENTER = (((0) << 12) | ((_VIEW_CENTER_) << 8) | ((0) << 4) | (_VIEW_CENTER_));

const uint32 B_FOLLOW_TOP = (((_VIEW_TOP_) << 12) | ((0) << 8) | ((_VIEW_TOP_) << 4) | (0));
const uint32 B_FOLLOW_BOTTOM = (((_VIEW_BOTTOM_) << 12) | ((0) << 8) | ((_VIEW_BOTTOM_) << 4) | (0));
const uint32 B_FOLLOW_TOP_BOTTOM = (((_VIEW_TOP_) << 12) | ((0) << 8) | ((_VIEW_BOTTOM_) << 4) | (0));
const uint32 B_FOLLOW_V_CENTER = (((_VIEW_CENTER_) << 12) | ((0) << 8) | ((_VIEW_CENTER_) << 4) | (0));

const uint32 B_FOLLOW_LEFT_TOP = B_FOLLOW_TOP | B_FOLLOW_LEFT;

class BBitmap;
class BCursor;
class BLayout;
class BLayoutContext;
class BLayoutItem;
class BMessage;
class BPicture;
class BPolygon;
class BRegion;
class BScrollBar;
class BScrollView;
class BShape;
class BShelf;
class BString;
class BToolTip;
class BWindow;
struct _array_data_;
struct _array_hdr_;
struct overlay_restrictions;

namespace BPrivate {
 class ViewState;
};


class BView : public BHandler {
public:
        BView(const char* name, uint32 flags,
         BLayout* layout = __null);
        BView(BRect frame, const char* name,
         uint32 resizingMode, uint32 flags);
 virtual ~BView();

        BView(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;
 virtual status_t AllUnarchived(const BMessage* archive);
 virtual status_t AllArchived(BMessage* archive) const;

 virtual void AttachedToWindow();
 virtual void AllAttached();
 virtual void DetachedFromWindow();
 virtual void AllDetached();

 virtual void MessageReceived(BMessage* message);

   void AddChild(BView* child, BView* before = __null);
   bool AddChild(BLayoutItem* child);
   bool RemoveChild(BView* child);
   int32 CountChildren() const;
   BView* ChildAt(int32 index) const;
   BView* NextSibling() const;
   BView* PreviousSibling() const;
   bool RemoveSelf();

   BWindow* Window() const;

 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);
 virtual void WindowActivated(bool active);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void KeyUp(const char* bytes, int32 numBytes);
 virtual void Pulse();
 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float newWidth, float newHeight);

 virtual void TargetedByScrollView(BScrollView* scrollView);
   void BeginRectTracking(BRect startRect,
         uint32 style = B_TRACK_WHOLE_RECT);
   void EndRectTracking();

   void GetMouse(BPoint* location, uint32* buttons,
         bool checkMessageQueue = true);

   void DragMessage(BMessage* message, BRect dragRect,
         BHandler* replyTo = __null);
   void DragMessage(BMessage* message, BBitmap* bitmap,
         BPoint offset, BHandler* replyTo = __null);
   void DragMessage(BMessage* message, BBitmap* bitmap,
         drawing_mode dragMode, BPoint offset,
         BHandler* replyTo = __null);

   BView* FindView(const char* name) const;
   BView* Parent() const;
   BRect Bounds() const;
   BRect Frame() const;
   void ConvertToScreen(BPoint* point) const;
   BPoint ConvertToScreen(BPoint point) const;
   void ConvertFromScreen(BPoint* point) const;
   BPoint ConvertFromScreen(BPoint point) const;
   void ConvertToScreen(BRect* rect) const;
   BRect ConvertToScreen(BRect rect) const;
   void ConvertFromScreen(BRect* rect) const;
   BRect ConvertFromScreen(BRect rect) const;
   void ConvertToParent(BPoint* point) const;
   BPoint ConvertToParent(BPoint point) const;
   void ConvertFromParent(BPoint* point) const;
   BPoint ConvertFromParent(BPoint point) const;
   void ConvertToParent(BRect* rect) const;
   BRect ConvertToParent(BRect rect) const;
   void ConvertFromParent(BRect* rect) const;
   BRect ConvertFromParent(BRect rect) const;
   BPoint LeftTop() const;

   void GetClippingRegion(BRegion* region) const;
 virtual void ConstrainClippingRegion(BRegion* region);
   void ClipToPicture(BPicture* picture,
         BPoint where = B_ORIGIN, bool sync = true);
   void ClipToInversePicture(BPicture* picture,
         BPoint where = B_ORIGIN, bool sync = true);

   void ClipToRect(BRect rect);
   void ClipToInverseRect(BRect rect);
   void ClipToShape(BShape* shape);
   void ClipToInverseShape(BShape* shape);

 virtual void SetDrawingMode(drawing_mode mode);
   drawing_mode DrawingMode() const;

   void SetBlendingMode(source_alpha srcAlpha,
         alpha_function alphaFunc);
   void GetBlendingMode(source_alpha* srcAlpha,
         alpha_function* alphaFunc) const;

 virtual void SetPenSize(float size);
   float PenSize() const;

   void SetViewCursor(const BCursor* cursor,
         bool sync = true);

   bool HasDefaultColors() const;
   bool HasSystemColors() const;
   void AdoptParentColors();
   void AdoptSystemColors();
   void AdoptViewColors(BView* view);

 virtual void SetViewColor(rgb_color color);
   void SetViewColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color ViewColor() const;

   void SetViewUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which ViewUIColor(float* tint = __null) const;

   void SetViewBitmap(const BBitmap* bitmap,
         BRect srcRect, BRect dstRect,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = B_TILE_BITMAP);
   void SetViewBitmap(const BBitmap* bitmap,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = B_TILE_BITMAP);
   void ClearViewBitmap();

   status_t SetViewOverlay(const BBitmap* overlay,
         BRect srcRect, BRect dstRect,
         rgb_color* colorKey,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = 0);
   status_t SetViewOverlay(const BBitmap* overlay,
         rgb_color* colorKey,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = 0);
   void ClearViewOverlay();

 virtual void SetHighColor(rgb_color color);
   void SetHighColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color HighColor() const;

   void SetHighUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which HighUIColor(float* tint = __null) const;

 virtual void SetLowColor(rgb_color color);
   void SetLowColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color LowColor() const;

   void SetLowUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which LowUIColor(float* tint = __null) const;

   void SetLineMode(cap_mode lineCap,
         join_mode lineJoin,
         float miterLimit = B_DEFAULT_MITER_LIMIT);
   join_mode LineJoinMode() const;
   cap_mode LineCapMode() const;
   float LineMiterLimit() const;

   void SetFillRule(int32 rule);
   int32 FillRule() const;

   void SetOrigin(BPoint where);
   void SetOrigin(float x, float y);
   BPoint Origin() const;




   void SetTransform(BAffineTransform transform);
   BAffineTransform Transform() const;
   void TranslateBy(double x, double y);
   void ScaleBy(double x, double y);
   void RotateBy(double angleRadians);

   BAffineTransform TransformTo(coordinate_space basis) const;

   void PushState();
   void PopState();

   void MovePenTo(BPoint pt);
   void MovePenTo(float x, float y);
   void MovePenBy(float x, float y);
   BPoint PenLocation() const;
   void StrokeLine(BPoint toPoint,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeLine(BPoint start, BPoint end,
         ::pattern pattern = B_SOLID_HIGH);
   void BeginLineArray(int32 count);
   void AddLine(BPoint start, BPoint end,
         rgb_color color);
   void EndLineArray();

   void StrokePolygon(const BPolygon* polygon,
         bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokePolygon(const BPoint* pointArray,
         int32 numPoints, bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokePolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPolygon* polygon,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPolygon* polygon,
         const BGradient& gradient);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, const BGradient& gradient);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         const BGradient& gradient);

   void StrokeTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeTriangle(BPoint point1, BPoint point2,
         BPoint point3,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, const BGradient& gradient);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         const BGradient& gradient);

   void StrokeRect(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRect(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRect(BRect rect, const BGradient& gradient);
   void FillRegion(BRegion* rectegion,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRegion(BRegion* rectegion,
         const BGradient& gradient);
   void InvertRect(BRect rect);

   void StrokeRoundRect(BRect rect, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRoundRect(BRect rect, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRoundRect(BRect rect, float xRadius,
         float yRadius, const BGradient& gradient);

   void StrokeEllipse(BPoint center, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeEllipse(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BPoint center, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BPoint center, float xRadius,
         float yRadius, const BGradient& gradient);
   void FillEllipse(BRect rect,
         const BGradient& gradient);

   void StrokeArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeArc(BRect rect, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BRect rect, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle, const BGradient& gradient);
   void FillArc(BRect rect, float startAngle,
         float arcAngle, const BGradient& gradient);

   void StrokeBezier(BPoint* controlPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillBezier(BPoint* controlPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillBezier(BPoint* controlPoints,
         const BGradient& gradient);

   void StrokeShape(BShape* shape,
         ::pattern pattern = B_SOLID_HIGH);
   void FillShape(BShape* shape,
         ::pattern pattern = B_SOLID_HIGH);
   void FillShape(BShape* shape,
         const BGradient& gradient);

   void CopyBits(BRect src, BRect dst);

   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect,
         uint32 options);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect viewRect);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BPoint where);
   void DrawBitmapAsync(const BBitmap* aBitmap);

   void DrawBitmap(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect,
         uint32 options);
   void DrawBitmap(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect);
   void DrawBitmap(const BBitmap* aBitmap,
         BRect viewRect);
   void DrawBitmap(const BBitmap* aBitmap,
         BPoint where);
   void DrawBitmap(const BBitmap* aBitmap);

   void DrawTiledBitmapAsync(const BBitmap* aBitmap,
         BRect viewRect, BPoint phase = B_ORIGIN);

   void DrawTiledBitmap(const BBitmap* aBitmap,
         BRect viewRect, BPoint phase = B_ORIGIN);

   void DrawChar(char aChar);
   void DrawChar(char aChar, BPoint location);
   void DrawString(const char* string,
         escapement_delta* delta = __null);
   void DrawString(const char* string,
         BPoint location,
         escapement_delta* delta = __null);
   void DrawString(const char* string, int32 length,
         escapement_delta* delta = __null);
   void DrawString(const char* string, int32 length,
         BPoint location,
         escapement_delta* delta = 0L);
   void DrawString(const char* string,
         const BPoint* locations,
         int32 locationCount);
   void DrawString(const char* string, int32 length,
         const BPoint* locations,
         int32 locationCount);

 virtual void SetFont(const BFont* font,
         uint32 mask = B_FONT_ALL);

   void GetFont(BFont* font) const;
   void TruncateString(BString* in_out, uint32 mode,
         float width) const;
   float StringWidth(const char* string) const;
   float StringWidth(const char* string,
         int32 length) const;
   void GetStringWidths(char* stringArray[],
         int32 lengthArray[], int32 numStrings,
         float widthArray[]) const;
   void SetFontSize(float size);
   void ForceFontAliasing(bool enable);
   void GetFontHeight(font_height* height) const;

   void Invalidate(BRect invalRect);
   void Invalidate(const BRegion* invalRegion);
   void Invalidate();
   void DelayedInvalidate(bigtime_t delay);
   void DelayedInvalidate(bigtime_t delay,
         BRect invalRect);

   void SetDiskMode(char* filename, long offset);

   void BeginPicture(BPicture* a_picture);
   void AppendToPicture(BPicture* a_picture);
   BPicture* EndPicture();

   void DrawPicture(const BPicture* a_picture);
   void DrawPicture(const BPicture* a_picture,
         BPoint where);
   void DrawPicture(const char* filename, long offset,
         BPoint where);
   void DrawPictureAsync(const BPicture* a_picture);
   void DrawPictureAsync(const BPicture* a_picture,
         BPoint where);
   void DrawPictureAsync(const char* filename,
         long offset, BPoint where);

   void BeginLayer(uint8 opacity);
   void EndLayer();

   status_t SetEventMask(uint32 mask, uint32 options = 0);
   uint32 EventMask();
   status_t SetMouseEventMask(uint32 mask,
         uint32 options = 0);

 virtual void SetFlags(uint32 flags);
   uint32 Flags() const;
 virtual void SetResizingMode(uint32 mode);
   uint32 ResizingMode() const;
   void MoveBy(float dh, float dv);
   void MoveTo(BPoint where);
   void MoveTo(float x, float y);
   void ResizeBy(float dh, float dv);
   void ResizeTo(float width, float height);
   void ResizeTo(BSize size);
   void ScrollBy(float dh, float dv);
   void ScrollTo(float x, float y);
 virtual void ScrollTo(BPoint where);
 virtual void MakeFocus(bool focus = true);
   bool IsFocus() const;

 virtual void Show();
 virtual void Hide();
   bool IsHidden() const;
   bool IsHidden(const BView* looking_from) const;

   void Flush() const;
   void Sync() const;

 virtual void GetPreferredSize(float* _width, float* _height);
 virtual void ResizeToPreferred();

   BScrollBar* ScrollBar(orientation direction) const;

 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
         BMessage* specifier, int32 form,
         const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

   bool IsPrinting() const;
   void SetScale(float scale) const;
   float Scale() const;


 virtual status_t Perform(perform_code code, void* data);

 virtual void DrawAfterChildren(BRect updateRect);



 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment LayoutAlignment();

   void SetExplicitMinSize(BSize size);
   void SetExplicitMaxSize(BSize size);
   void SetExplicitPreferredSize(BSize size);
   void SetExplicitSize(BSize size);
   void SetExplicitAlignment(BAlignment alignment);

   BSize ExplicitMinSize() const;
   BSize ExplicitMaxSize() const;
   BSize ExplicitPreferredSize() const;
   BAlignment ExplicitAlignment() const;

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

   void InvalidateLayout(bool descendants = false);
 virtual void SetLayout(BLayout* layout);
   BLayout* GetLayout() const;

   void EnableLayoutInvalidation();
   void DisableLayoutInvalidation();
   bool IsLayoutInvalidationDisabled();
   bool IsLayoutValid() const;
   void ResetLayoutInvalidation();

   BLayoutContext* LayoutContext() const;

   void Layout(bool force);
   void Relayout();

 class Private;

protected:
 virtual void LayoutInvalidated(bool descendants = false);
 virtual void DoLayout();

public:


   void SetToolTip(const char* text);
   void SetToolTip(BToolTip* tip);
   BToolTip* ToolTip() const;

   void ShowToolTip(BToolTip* tip = __null);
   void HideToolTip();

protected:
 virtual bool GetToolTipAt(BPoint point, BToolTip** _tip);

 virtual void LayoutChanged();

   status_t ScrollWithMouseWheelDelta(BScrollBar*, float);

private:
   void _Layout(bool force, BLayoutContext* context);
   void _LayoutLeft(BLayout* deleted);
   void _InvalidateParentLayout();

private:

 virtual void _ReservedView13();
 virtual void _ReservedView14();
 virtual void _ReservedView15();
 virtual void _ReservedView16();

        BView(const BView&);
   BView& operator=(const BView&);

private:
 struct LayoutData;

 friend class Private;
 friend class BBitmap;
 friend class BLayout;
 friend class BPrintJob;
 friend class BScrollBar;
 friend class BShelf;
 friend class BTabView;
 friend class BWindow;

   void _InitData(BRect frame, const char* name,
         uint32 resizingMode, uint32 flags);
   status_t _SetViewBitmap(const BBitmap* bitmap,
         BRect srcRect, BRect dstRect,
         uint32 followFlags, uint32 options);
   void _ClipToPicture(BPicture* picture, BPoint where,
         bool invert, bool sync);

   void _ClipToRect(BRect rect, bool inverse);
   void _ClipToShape(BShape* shape, bool inverse);

   bool _CheckOwnerLockAndSwitchCurrent() const;
   bool _CheckOwnerLock() const;
   void _CheckLockAndSwitchCurrent() const;
   void _CheckLock() const;
   void _SwitchServerCurrentView() const;

   void _SetOwner(BWindow* newOwner);
   void _RemoveCommArray();

   BShelf* _Shelf() const;
   void _SetShelf(BShelf* shelf);

   void _MoveTo(int32 x, int32 y);
   void _ResizeBy(int32 deltaWidth, int32 deltaHeight);
   void _ParentResizedBy(int32 deltaWidth,
         int32 deltaHeight);

   void _ConvertToScreen(BPoint* pt,
         bool checkLock) const;
   void _ConvertFromScreen(BPoint* pt,
         bool checkLock) const;

   void _ConvertToParent(BPoint* pt,
         bool checkLock) const;
   void _ConvertFromParent(BPoint* pt,
         bool checkLock) const;

   void _Activate(bool state);
   void _Attach();
   void _ColorsUpdated(BMessage* message);
   void _Detach();
   void _Draw(BRect screenUpdateRect);
   void _DrawAfterChildren(BRect screenUpdateRect);
   void _FontsUpdated(BMessage*);
   void _Pulse();

   void _UpdateStateForRemove();
   void _UpdatePattern(::pattern pattern);

   void _FlushIfNotInTransaction();

   bool _CreateSelf();
   bool _AddChildToList(BView* child,
         BView* before = __null);
   bool _RemoveChildFromList(BView* child);

   bool _AddChild(BView *child, BView *before);
   bool _RemoveSelf();
   void _RemoveLayoutItemsFromLayout(bool deleteItems);


   void _PrintToStream();
   void _PrintTree();

   int32 _unused_int1;

   uint32 fFlags;
   BPoint fParentOffset;
   BWindow* fOwner;
   BView* fParent;
   BView* fNextSibling;
   BView* fPreviousSibling;
   BView* fFirstChild;

   int16 fShowLevel;
   bool fTopLevelView;
   bool fNoISInteraction;
   BPicture* fCurrentPicture;
   _array_data_* fCommArray;

   BScrollBar* fVerScroller;
   BScrollBar* fHorScroller;
   bool fIsPrinting;
   bool fAttached;
   bool _unused_bool1;
   bool _unused_bool2;
   ::BPrivate::ViewState* fState;
   BRect fBounds;
   BShelf* fShelf;
   uint32 fEventMask;
   uint32 fEventOptions;
   uint32 fMouseEventOptions;

   LayoutData* fLayoutData;
   BToolTip* fToolTip;

   uint32 _reserved[6];
};





inline void
BView::ScrollTo(float x, float y)
{
 ScrollTo(BPoint(x, y));
}


inline void
BView::SetViewColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetViewColor(color);
}


inline void
BView::SetHighColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetHighColor(color);
}


inline void
BView::SetLowColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetLowColor(color);
}


class BButton;
class BMenuBar;
class BMenuItem;
class BMessage;
class BMessageRunner;
class BMessenger;
class BView;

namespace BPrivate {
 class PortLink;
};


enum window_type {
 B_UNTYPED_WINDOW = 0,
 B_TITLED_WINDOW = 1,
 B_MODAL_WINDOW = 3,
 B_DOCUMENT_WINDOW = 11,
 B_BORDERED_WINDOW = 20,
 B_FLOATING_WINDOW = 21
};

enum window_look {
 B_BORDERED_WINDOW_LOOK = 20,
 B_NO_BORDER_WINDOW_LOOK = 19,
 B_TITLED_WINDOW_LOOK = 1,
 B_DOCUMENT_WINDOW_LOOK = 11,
 B_MODAL_WINDOW_LOOK = 3,
 B_FLOATING_WINDOW_LOOK = 7
};

enum window_feel {
 B_NORMAL_WINDOW_FEEL = 0,
 B_MODAL_SUBSET_WINDOW_FEEL = 2,
 B_MODAL_APP_WINDOW_FEEL = 1,
 B_MODAL_ALL_WINDOW_FEEL = 3,
 B_FLOATING_SUBSET_WINDOW_FEEL = 5,
 B_FLOATING_APP_WINDOW_FEEL = 4,
 B_FLOATING_ALL_WINDOW_FEEL = 6
};

enum window_alignment {
 B_BYTE_ALIGNMENT = 0,
 B_PIXEL_ALIGNMENT = 1
};


enum {
 B_NOT_MOVABLE = 0x00000001,
 B_NOT_CLOSABLE = 0x00000020,
 B_NOT_ZOOMABLE = 0x00000040,
 B_NOT_MINIMIZABLE = 0x00004000,
 B_NOT_RESIZABLE = 0x00000002,
 B_NOT_H_RESIZABLE = 0x00000004,
 B_NOT_V_RESIZABLE = 0x00000008,
 B_AVOID_FRONT = 0x00000080,
 B_AVOID_FOCUS = 0x00002000,
 B_WILL_ACCEPT_FIRST_CLICK = 0x00000010,
 B_OUTLINE_RESIZE = 0x00001000,
 B_NO_WORKSPACE_ACTIVATION = 0x00000100,
 B_NOT_ANCHORED_ON_ACTIVATE = 0x00020000,
 B_ASYNCHRONOUS_CONTROLS = 0x00080000,
 B_QUIT_ON_WINDOW_CLOSE = 0x00100000,
 B_SAME_POSITION_IN_ALL_WORKSPACES = 0x00200000,
 B_AUTO_UPDATE_SIZE_LIMITS = 0x00400000,
 B_CLOSE_ON_ESCAPE = 0x00800000,
 B_NO_SERVER_SIDE_WINDOW_MODIFIERS = 0x00000200
};





enum {
 B_DO_NOT_RESIZE_TO_FIT = 0x0001,
 B_MOVE_IF_PARTIALLY_OFFSCREEN = 0x0002
};


class BWindow : public BLooper {
public:
        BWindow(BRect frame, const char* title,
         window_type type, uint32 flags,
         uint32 workspace = 0);
        BWindow(BRect frame, const char* title,
         window_look look, window_feel feel,
         uint32 flags, uint32 workspace
          = 0);
 virtual ~BWindow();

        BWindow(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void Quit();
   void Close() { Quit(); }

   void AddChild(BView* child, BView* before = __null);
   void AddChild(BLayoutItem* child);
   bool RemoveChild(BView* child);
   int32 CountChildren() const;
   BView* ChildAt(int32 index) const;

 virtual void DispatchMessage(BMessage* message,
         BHandler* handler);
 virtual void MessageReceived(BMessage* message);
 virtual void FrameMoved(BPoint newPosition);
 virtual void WorkspacesChanged(uint32 oldWorkspaces,
         uint32 newWorkspaces);
 virtual void WorkspaceActivated(int32 workspace,
         bool state);
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void Minimize(bool minimize);
 virtual void Zoom(BPoint origin, float width, float height);
   void Zoom();
   void SetZoomLimits(float maxWidth, float maxHeight);
 virtual void ScreenChanged(BRect screenSize,
         color_space depth);

   void SetPulseRate(bigtime_t rate);
   bigtime_t PulseRate() const;

   void AddShortcut(uint32 key, uint32 modifiers,
         BMessage* message);
   void AddShortcut(uint32 key, uint32 modifiers,
         BMessage* message, BHandler* target);
   bool HasShortcut(uint32 key, uint32 modifiers);
   void RemoveShortcut(uint32 key, uint32 modifiers);

   void SetDefaultButton(BButton* button);
   BButton* DefaultButton() const;

 virtual void MenusBeginning();
 virtual void MenusEnded();

   bool NeedsUpdate() const;
   void UpdateIfNeeded();

   BView* FindView(const char* viewName) const;
   BView* FindView(BPoint) const;
   BView* CurrentFocus() const;

   void Activate(bool = true);
 virtual void WindowActivated(bool focus);

   void ConvertToScreen(BPoint* point) const;
   BPoint ConvertToScreen(BPoint point) const;
   void ConvertFromScreen(BPoint* point) const;
   BPoint ConvertFromScreen(BPoint point) const;
   void ConvertToScreen(BRect* rect) const;
   BRect ConvertToScreen(BRect rect) const;
   void ConvertFromScreen(BRect* rect) const;
   BRect ConvertFromScreen(BRect rect) const;

   void MoveBy(float dx, float dy);
   void MoveTo(BPoint);
   void MoveTo(float x, float y);
   void ResizeBy(float dx, float dy);
   void ResizeTo(float width, float height);
   void ResizeToPreferred();

   void CenterIn(const BRect& rect);
   void CenterOnScreen();
   void CenterOnScreen(screen_id id);
   void MoveOnScreen(uint32 flags = 0);

 virtual void Show();
 virtual void Hide();
   bool IsHidden() const;
   bool IsMinimized() const;

   void Flush() const;
   void Sync() const;

   status_t SendBehind(const BWindow* window);

   void DisableUpdates();
   void EnableUpdates();

   void BeginViewTransaction();


   void EndViewTransaction();


   bool InViewTransaction() const;

   BRect Bounds() const;
   BRect Frame() const;
   BRect DecoratorFrame() const;
   BSize Size() const;
   const char* Title() const;
   void SetTitle(const char* title);
   bool IsFront() const;
   bool IsActive() const;

   void SetKeyMenuBar(BMenuBar* bar);
   BMenuBar* KeyMenuBar() const;

   void SetSizeLimits(float minWidth, float maxWidth,
         float minHeight, float maxHeight);
   void GetSizeLimits(float* minWidth, float* maxWidth,
         float* minHeight, float* maxHeight);
   void UpdateSizeLimits();

   status_t SetDecoratorSettings(const BMessage& settings);
   status_t GetDecoratorSettings(BMessage* settings) const;

   uint32 Workspaces() const;
   void SetWorkspaces(uint32);

   BView* LastMouseMovedView() const;

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

   status_t AddToSubset(BWindow* window);
   status_t RemoveFromSubset(BWindow* window);

 virtual status_t Perform(perform_code code, void* data);

   status_t SetType(window_type type);
   window_type Type() const;

   status_t SetLook(window_look look);
   window_look Look() const;

   status_t SetFeel(window_feel feel);
   window_feel Feel() const;

   status_t SetFlags(uint32);
   uint32 Flags() const;

   bool IsModal() const;
   bool IsFloating() const;

   status_t SetWindowAlignment(window_alignment mode,
         int32 h, int32 hOffset = 0,
         int32 width = 0, int32 widthOffset = 0,
         int32 v = 0, int32 vOffset = 0,
         int32 height = 0, int32 heightOffset = 0);
   status_t GetWindowAlignment(
         window_alignment* mode = __null,
         int32* h = __null, int32* hOffset = __null,
         int32* width = __null,
         int32* widthOffset = __null,
         int32* v = __null, int32* vOffset = __null,
         int32* height = __null,
         int32* heightOffset = __null) const;

 virtual bool QuitRequested();
 virtual thread_id Run();

 virtual void SetLayout(BLayout* layout);
   BLayout* GetLayout() const;

   void InvalidateLayout(bool descendants = false);
   void Layout(bool force);
   bool IsOffscreenWindow() const;
private:

 virtual void _ReservedWindow2();
 virtual void _ReservedWindow3();
 virtual void _ReservedWindow4();
 virtual void _ReservedWindow5();
 virtual void _ReservedWindow6();
 virtual void _ReservedWindow7();
 virtual void _ReservedWindow8();

        BWindow();
        BWindow(BWindow&);
   BWindow& operator=(BWindow&);

private:
 typedef BLooper inherited;
 struct unpack_cookie;
 class Shortcut;

 friend class BAlert;
 friend class BApplication;
 friend class BBitmap;
 friend class BView;
 friend class BMenuItem;
 friend class BWindowScreen;
 friend class BDirectWindow;
 friend class BFilePanel;
 friend class BWindowStack;

 friend void _set_menu_sem_(BWindow* w, sem_id sem);
 friend status_t _safe_get_server_token_(const BLooper*, int32*);

        BWindow(BRect frame, int32 bitmapToken);
   void _InitData(BRect frame, const char* title,
         window_look look, window_feel feel,
         uint32 flags, uint32 workspace,
         int32 bitmapToken = -1);

 virtual void task_looper();

   BPoint AlertPosition(const BRect& frame);
 virtual BMessage* ConvertToMessage(void* raw, int32 code);

   void AddShortcut(uint32 key, uint32 modifiers,
         BMenuItem* item);
   BHandler* _DetermineTarget(BMessage* message,
         BHandler* target);
   bool _IsFocusMessage(BMessage* message);
   bool _UnpackMessage(unpack_cookie& state,
         BMessage** _message, BHandler** _target,
         bool* _usePreferred);
   void _SanitizeMessage(BMessage* message,
         BHandler* target, bool usePreferred);
   bool _StealMouseMessage(BMessage* message,
         bool& deleteMessage);
   uint32 _TransitForMouseMoved(BView* view,
         BView* viewUnderMouse) const;

   bool InUpdate();
   void _DequeueAll();
   window_type _ComposeType(window_look look,
         window_feel feel) const;
   void _DecomposeType(window_type type,
         window_look* look,
         window_feel* feel) const;

   void SetIsFilePanel(bool yes);
   bool IsFilePanel() const;

   void _CreateTopView();
   void _AdoptResize();
   void _SetFocus(BView* focusView,
         bool notifyIputServer = false);
   void _SetName(const char* title);

   Shortcut* _FindShortcut(uint32 key, uint32 modifiers);
   BView* _FindView(BView* view, BPoint point) const;
   BView* _FindView(int32 token);
   BView* _LastViewChild(BView* parent);

   BView* _FindNextNavigable(BView* focus, uint32 flags);
   BView* _FindPreviousNavigable(BView* focus,
         uint32 flags);
   void _Switcher(int32 rawKey, uint32 modifiers,
         bool repeat);
   bool _HandleKeyDown(BMessage* event);
   bool _HandleUnmappedKeyDown(BMessage* event);
   void _KeyboardNavigation();

   void _GetDecoratorSize(float* _borderWidth,
         float* _tabHeight) const;
   void _SendShowOrHideMessage();
   void _PropagateMessageToChildViews(BMessage*);

private:
   char* fTitle;
   int32 _unused0;
   bool fInTransaction;
   bool fActive;
   short fShowLevel;
   uint32 fFlags;

   BView* fTopView;
   BView* fFocus;
   BView* fLastMouseMovedView;
   uint32 _unused1;
   BMenuBar* fKeyMenuBar;
   BButton* fDefaultButton;
   BList fShortcuts;
   int32 fTopViewToken;
   bool fUpdateRequested;
   bool fOffscreen;
   bool fIsFilePanel;
   bool _unused4;
   bigtime_t fPulseRate;
   bool _unused5;
   bool fMinimized;
   bool fNoQuitShortcut;
   bool _unused6;
   sem_id fMenuSem;
   float fMaxZoomHeight;
   float fMaxZoomWidth;
   float fMinHeight;
   float fMinWidth;
   float fMaxHeight;
   float fMaxWidth;
   BRect fFrame;
   window_look fLook;
   window_feel fFeel;
   int32 fLastViewToken;
   ::BPrivate::PortLink* fLink;
   BMessageRunner* fPulseRunner;
   BRect fPreviousFrame;

   uint32 _reserved[9];
};


class MainView :
 public BView
{
public:
 MainView (BRect);
 ~MainView ();

 void AttachedToWindow();
private:

};

class AppWindow : public BWindow
{
 public:
  AppWindow();
  ~AppWindow();

  void WindowActivated(bool);
  void MessageReceived (BMessage* in);
  bool QuitRequested();
 private:
  MainView* mainView;
};

class MainApp : public BApplication
{
 public:
  MainApp ();
  ~MainApp();

  void ReadyToRun();

 private:
  AppWindow *window;

};


int main (void);

MainApp::MainApp ()
 : BApplication ("application/x-vnd.hitech.EsperantoFilterSettings")
{

}


MainApp::~MainApp ()
{

}

void MainApp::ReadyToRun() {
    window = new AppWindow();
    window->Show();
}




int main()
{
 MainApp *app = new MainApp;


   app->Run();

   delete be_app;
   return 0;
}

typedef off_t fpos_t;

struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;


struct _IO_marker {
 struct _IO_marker *_next;
 struct _IO_FILE *_sbuf;
 int _pos;
};

typedef struct _IO_FILE {
 int _flags;




 char *_IO_read_ptr;
 char *_IO_read_end;
 char *_IO_read_base;
 char *_IO_write_base;
 char *_IO_write_ptr;
 char *_IO_write_end;
 char *_IO_buf_base;
 char *_IO_buf_end;

 char *_IO_save_base;
 char *_IO_backup_base;
 char *_IO_save_end;

 struct _IO_marker *_markers;

 struct _IO_FILE *_chain;

 int _fileno;

 int _flags2;
 off_t _old_offset;



 unsigned short _cur_column;
 signed char _vtable_offset;
 char _shortbuf[1];

 _IO_lock_t *_lock;

 off_t _offset;


 struct _IO_codecvt *_codecvt;
 struct _IO_wide_data *_wide_data;




 int _mode;

 char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];
} _IO_FILE;



extern "C" {


extern int _IO_feof(_IO_FILE *stream);

extern int _IO_ferror(_IO_FILE *stream);

extern int _IO_putc(int c, _IO_FILE *stream);
extern int _IO_getc(_IO_FILE *stream);

extern int __underflow(_IO_FILE *stream);
extern int __uflow(_IO_FILE *stream);
extern int __overflow(_IO_FILE *stream, int c);

extern int _IO_peekc_locked(_IO_FILE *stream);





extern void _IO_flockfile(_IO_FILE *);
extern void _IO_funlockfile(_IO_FILE *);
extern int _IO_ftrylockfile(_IO_FILE *);
extern int _IO_vfscanf(_IO_FILE *, const char *, va_list, int *);
extern int _IO_vfprintf(_IO_FILE *, const char *, va_list);
extern ssize_t _IO_padn(_IO_FILE *, int, ssize_t);
extern size_t _IO_sgetn(_IO_FILE *, void *, size_t);

extern off_t _IO_seekoff(_IO_FILE *, off_t, int, int);
extern off_t _IO_seekpos(_IO_FILE *, off_t, int);

extern void _IO_free_backup_area(_IO_FILE *);
}

typedef struct _IO_FILE FILE;

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;



extern "C" {



extern FILE *fopen(const char *name, const char *mode);
extern FILE *freopen(const char *name, const char *mode, FILE *stream);
extern FILE *fdopen(int fd, const char *mode);
extern int fclose(FILE *stream);




extern int fileno(FILE *stream);
extern int fileno_unlocked(FILE *stream);

extern int ferror(FILE *stream);
extern int ferror_unlocked(FILE *stream);
extern void clearerr(FILE *stream);
extern void clearerr_unlocked(FILE *stream);

extern int feof(FILE *stream);
extern int feof_unlocked(FILE *stream);

extern void flockfile(FILE *stream);
extern void funlockfile(FILE *stream);
extern int ftrylockfile(FILE *stream);

extern int remove(const char *name);
extern int rename(const char *from, const char *to);
extern int renameat(int fromFD, const char *from, int toFD, const char *to);


extern FILE *popen(const char *command, const char *mode);
extern int pclose(FILE *stream);
extern void perror(const char *errorPrefix);


extern FILE *fmemopen(void *buf, size_t size, const char *mode);
extern FILE *open_memstream(char **buf, size_t *size);
extern int fflush(FILE *stream);
extern int fflush_unlocked(FILE *stream);
extern int fpurge(FILE *stream);

extern int fgetpos(FILE *stream, fpos_t *position);
extern int fsetpos(FILE *stream, const fpos_t *position);
extern int fseek(FILE *stream, long offset, int seekType);
extern int fseeko(FILE *stream, off_t offset, int seekType);
extern int _fseek(FILE *stream, fpos_t offset, int seekType);
extern long ftell(FILE *stream);
extern off_t ftello(FILE *stream);
extern fpos_t _ftell(FILE *stream);

extern void rewind(FILE *stream);

extern void setbuf (FILE *file, char *buff);
extern int setvbuf(FILE *file, char *buff, int mode, size_t size);
extern int setbuffer(FILE *stream, char *buf, size_t size);
extern int setlinebuf(FILE *stream);

extern size_t fwrite(const void *buffer, size_t size, size_t numItems, FILE *stream);
extern size_t fwrite_unlocked(const void *buffer, size_t size, size_t numItems, FILE *stream);
extern size_t fread(void *buffer, size_t size, size_t numItems, FILE *stream);
extern size_t fread_unlocked(void *buffer, size_t size, size_t numItems, FILE *stream);

extern int putc(int c, FILE *stream);
extern int putchar(int c);
extern int putc_unlocked(int c, FILE *stream);
extern int putchar_unlocked(int c);
extern int fputc(int c, FILE *stream);
extern int fputc_unlocked(int c, FILE *stream);
extern int puts(const char *string);
extern int fputs(const char *string, FILE *stream);
extern int fputs_unlocked(const char *string, FILE *stream);

extern int getc(FILE *stream);
extern int getc_unlocked(FILE *stream);
extern int ungetc(int c, FILE *stream);
extern int getchar(void);
extern int getchar_unlocked(void);
extern int fgetc(FILE *stream);
extern int fgetc_unlocked(FILE *stream);
extern char *gets(char *buffer);
extern char *fgets(char *string, int stringLength, FILE *stream);
extern char *fgets_unlocked(char *string, int stringLength, FILE *stream);

extern ssize_t getdelim(char **_line, size_t *_length, int delimiter,
     FILE *stream);
extern ssize_t getline(char **_line, size_t *_length, FILE *stream);


extern int printf(char const *format, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

extern int dprintf(int fd, char const *format, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

extern int fprintf(FILE *stream, char const *format, ...) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int sprintf(char *string, char const *format, ...) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int snprintf(char *string, size_t size, char const *format, ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int vprintf(char const *format, va_list ap);
extern int vfprintf(FILE *stream, char const *format, va_list ap);
extern int vsprintf(char *string, char const *format, va_list ap);
extern int vsnprintf(char *string, size_t size, char const *format, va_list ap);

extern int scanf(char const *format, ...);
extern int fscanf(FILE *stream, char const *format, ...);
extern int sscanf(char const *str, char const *format, ...);
extern int vscanf(char const *format, va_list ap);
extern int vsscanf(char const *str, char const *format, va_list ap);
extern int vfscanf(FILE *stream, char const *format, va_list ap);


extern char *ctermid(char *controllingTerminal);
extern char *cuserid(char *s);


extern char *tempnam(char const *path, char const *prefix);
extern FILE *tmpfile(void);
extern char *tmpnam(char *nameBuffer);
extern char *tmpnam_r(char *nameBuffer);

extern "C" {


extern char _single_threaded;





}


}

AppWindow::AppWindow () :
 BWindow (BRect (100, 100, 500, 500),
    "Esperanto Filter",
    B_TITLED_WINDOW,
    B_NOT_ZOOMABLE | B_NOT_RESIZABLE | B_ASYNCHRONOUS_CONTROLS)
{
 mainView = new MainView (Bounds());
 AddChild (mainView);
}


bool AppWindow::QuitRequested() {
 be_app->PostMessage(B_QUIT_REQUESTED);
 return BWindow::QuitRequested();
}


AppWindow::~AppWindow ()
{

}


void AppWindow::WindowActivated (bool active)
{
 BWindow::WindowActivated(active);
}


void AppWindow::MessageReceived (BMessage *in)
{
 BWindow::MessageReceived(in);
 switch (in->what)
 {
  case B_UNMAPPED_KEY_DOWN:
   break;
  case B_MODIFIERS_CHANGED:
   break;
 };
}





extern "C" {
struct sched_param {
 int sched_priority;
};


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);


}
struct __pthread_cleanup_handler {
 struct __pthread_cleanup_handler *previous;
 void (*function)(void *argument);
 void *argument;
};
extern "C" {
extern int pthread_mutex_destroy(pthread_mutex_t *mutex);
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *mutex,
 int *_priorityCeiling);
extern int pthread_mutex_init(pthread_mutex_t *mutex,
 const pthread_mutexattr_t *attr);
extern int pthread_mutex_lock(pthread_mutex_t *mutex);
extern int pthread_mutex_setprioceiling(pthread_mutex_t *mutex,
 int newPriorityCeiling, int *_oldPriorityCeiling);
extern int pthread_mutex_clocklock(pthread_mutex_t *mutex,
 clockid_t clock_id, const struct timespec *abstime);
extern int pthread_mutex_timedlock(pthread_mutex_t *mutex,
 const struct timespec *abstime);
extern int pthread_mutex_trylock(pthread_mutex_t *mutex);
extern int pthread_mutex_unlock(pthread_mutex_t *mutex);


extern int pthread_mutexattr_destroy(pthread_mutexattr_t *mutexAttr);
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *mutexAttr,
 int *_priorityCeiling);
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *mutexAttr,
 int *_protocol);
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *mutexAttr,
 int *_processShared);
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *mutexAttr,
 int *_type);
extern int pthread_mutexattr_init(pthread_mutexattr_t *mutexAttr);
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *mutexAttr,
 int priorityCeiling);
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *mutexAttr,
 int protocol);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *mutexAttr,
 int processShared);
extern int pthread_mutexattr_settype(pthread_mutexattr_t *mutexAttr, int type);


extern int pthread_barrier_init(pthread_barrier_t *barrier,
 const pthread_barrierattr_t *attr, unsigned count);
extern int pthread_barrier_destroy(pthread_barrier_t *barrier);
extern int pthread_barrier_wait(pthread_barrier_t *barrier);


extern int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr,
 int *shared);
extern int pthread_barrierattr_init(pthread_barrierattr_t *attr);
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,
 int shared);


extern int pthread_cond_destroy(pthread_cond_t *cond);
extern int pthread_cond_init(pthread_cond_t *cond,
 const pthread_condattr_t *attr);
extern int pthread_cond_broadcast(pthread_cond_t *cond);
extern int pthread_cond_signal(pthread_cond_t *cond);
extern int pthread_cond_clockwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 clockid_t clock_id, const struct timespec *abstime);
extern int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 const struct timespec *abstime);
extern int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);


extern int pthread_condattr_destroy(pthread_condattr_t *condAttr);
extern int pthread_condattr_init(pthread_condattr_t *condAttr);
extern int pthread_condattr_getpshared(const pthread_condattr_t *condAttr,
 int *processShared);
extern int pthread_condattr_setpshared(pthread_condattr_t *condAttr,
 int processShared);
extern int pthread_condattr_getclock(const pthread_condattr_t *condAttr,
 clockid_t *clockID);
extern int pthread_condattr_setclock(pthread_condattr_t *condAttr,
 clockid_t clockID);


extern int pthread_rwlock_init(pthread_rwlock_t *lock,
 const pthread_rwlockattr_t *attr);
extern int pthread_rwlock_destroy(pthread_rwlock_t *lock);
extern int pthread_rwlock_rdlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_clockrdlock(pthread_rwlock_t* rwlock,
 clockid_t clock_id, const struct timespec* abstime);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *lock,
 const struct timespec *abstime);
extern int pthread_rwlock_wrlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_clockwrlock(pthread_rwlock_t* rwlock,
 clockid_t clock_id, const struct timespec* abstime);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *lock,
 const struct timespec *abstime);
extern int pthread_rwlock_unlock(pthread_rwlock_t *lock);


extern int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr,
 int *shared);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
 int shared);


extern int pthread_spin_init(pthread_spinlock_t* spinlock, int pshared);
extern int pthread_spin_destroy(pthread_spinlock_t* spinlock);
extern int pthread_spin_lock(pthread_spinlock_t* spinlock);
extern int pthread_spin_trylock(pthread_spinlock_t* spinlock);
extern int pthread_spin_unlock(pthread_spinlock_t* spinlock);


extern int pthread_atfork(void (*prepare)(void), void (*parent)(void),
 void (*child)(void));
extern int pthread_once(pthread_once_t *once_control,
 void (*init_routine)(void));


extern int pthread_attr_destroy(pthread_attr_t *attr);
extern int pthread_attr_init(pthread_attr_t *attr);
extern int pthread_attr_getdetachstate(const pthread_attr_t *attr,
 int *detachstate);
extern int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
extern int pthread_attr_getstacksize(const pthread_attr_t *attr,
 size_t *stacksize);
extern int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
extern int pthread_attr_getscope(const pthread_attr_t *attr,
 int *contentionScope);
extern int pthread_attr_setscope(pthread_attr_t *attr, int contentionScope);

extern int pthread_attr_getschedparam(const pthread_attr_t *attr,
 struct sched_param *param);
extern int pthread_attr_setschedparam(pthread_attr_t *attr,
 const struct sched_param *param);

extern int pthread_attr_getguardsize(const pthread_attr_t *attr,
 size_t *guardsize);
extern int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);

extern int pthread_attr_getstack(const pthread_attr_t *attr,
 void **stackaddr, size_t *stacksize);
extern int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
 size_t stacksize);
extern int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
 void *(*start_routine)(void*), void *arg);
extern int pthread_detach(pthread_t thread);
extern int pthread_equal(pthread_t t1, pthread_t t2);
extern void pthread_exit(void *value_ptr) __attribute__ ((noreturn));
extern int pthread_join(pthread_t thread, void **_value);
extern pthread_t pthread_self(void);
extern int pthread_getconcurrency(void);
extern int pthread_setconcurrency(int newLevel);

extern int pthread_cancel(pthread_t thread);
extern int pthread_setcancelstate(int state, int *_oldState);
extern int pthread_setcanceltype(int type, int *_oldType);
extern void pthread_testcancel(void);

extern int pthread_getschedparam(pthread_t thread, int *policy,
 struct sched_param *param);
extern int pthread_setschedparam(pthread_t thread, int policy,
 const struct sched_param *param);


extern int pthread_key_create(pthread_key_t *key,
 void (*destructorFunc)(void*));
extern int pthread_key_delete(pthread_key_t key);
extern void *pthread_getspecific(pthread_key_t key);
extern int pthread_setspecific(pthread_key_t key, const void *value);


extern void __pthread_cleanup_push_handler(
 struct __pthread_cleanup_handler *handler);
extern struct __pthread_cleanup_handler *__pthread_cleanup_pop_handler(void);


}





class BBitmap;
class BCatalog;
class BCollator;
class BCountry;
class BDateFormat;
class BFormattingConventions;
class BLanguage;
class BLocale;
class BMessage;
class BTimeZone;


namespace BPrivate {
 struct LocaleRosterData;
}


enum {
 B_LOCALE_CHANGED = '_LCC',
};


class BLocaleRoster {

public:
        ~BLocaleRoster();

 static BLocaleRoster* Default();

   status_t GetDefaultTimeZone(BTimeZone* timezone) const;

   status_t GetLanguage(const char* languageCode,
         BLanguage** _language) const;

   status_t GetPreferredLanguages(BMessage* message) const;

   status_t GetAvailableLanguages(BMessage* message) const;
   status_t GetAvailableCountries(
         BMessage* timeZones) const;
   status_t GetAvailableTimeZones(
         BMessage* timeZones) const;
   status_t GetAvailableTimeZonesWithRegionInfo(
         BMessage* timeZonesWithRegonInfo) const;
   status_t GetAvailableTimeZonesForCountry(
         BMessage* message,
         const char* countryCode) const;

   status_t GetFlagIconForCountry(BBitmap* flagIcon,
         const char* countryCode);
   status_t GetFlagIconForLanguage(BBitmap* flagIcon,
         const char* languageCode);

   status_t GetAvailableCatalogs(BMessage* message,
         const char* sigPattern = __null,
         const char* langPattern = __null,
         int32 fingerprint = 0) const;


   status_t Refresh();



   BCatalog* GetCatalog();



   const BLocale* GetDefaultLocale() const;

   bool IsFilesystemTranslationPreferred() const;

   status_t GetLocalizedFileName(BString& localizedFileName,
         const entry_ref& ref,
         bool traverse = false);

 static const char* kCatLangAttr;
 static const char* kCatSigAttr;
 static const char* kCatFingerprintAttr;

 static const char* kEmbeddedCatAttr;
 static int32 kEmbeddedCatResId;

protected:
        BLocaleRoster();

protected:
   BPrivate::LocaleRosterData* fData;

private:
 static BCatalog* _GetCatalog(BCatalog* catalog,
         int32* catalogInitStatus);

   status_t _PrepareCatalogEntry(const entry_ref& ref,
         BString& signature, BString& context,
         BString& string, bool traverse);

};
class BLocker {
public:
        BLocker();
        BLocker(const char* name);
        BLocker(bool benaphoreStyle);
        BLocker(const char* name, bool benaphoreStyle);
 virtual ~BLocker();

   status_t InitCheck() const;

   bool Lock();
   status_t LockWithTimeout(bigtime_t timeout);
   void Unlock();

   thread_id LockingThread() const;
   bool IsLocked() const;
   int32 CountLocks() const;
   int32 CountLockRequests() const;
   sem_id Sem() const;

private:
        BLocker(const char* name, bool benaphoreStyle,
         bool _ignored);
        BLocker(const BLocker&);
        BLocker& operator=(const BLocker&);
   void InitLocker(const char* name,
         bool benaphoreStyle);
   bool AcquireLock(bigtime_t timeout, status_t* error);

   int32 fBenaphoreCount;
   sem_id fSemaphoreID;
   thread_id fLockOwner;
   int32 fRecursiveCount;

   int32 _reserved[4];
};




class BCatalogData;
class BLocale;
class BMessage;
struct entry_ref;


class BCatalog {
public:
        BCatalog();
        BCatalog(const entry_ref& catalogOwner,
         const char* language = __null,
         uint32 fingerprint = 0);
        BCatalog(const char* signature,
         const char* language = __null);

 virtual ~BCatalog();

   const char* GetString(const char* string,
         const char* context = __null,
         const char* comment = __null);
   const char* GetString(uint32 id);

   status_t GetData(const char* name, BMessage* msg);
   status_t GetData(uint32 id, BMessage* msg);

   status_t GetSignature(BString* signature);
   status_t GetLanguage(BString* language);
   status_t GetFingerprint(uint32* fingerprint);

   status_t SetTo(const entry_ref& catalogOwner,
         const char* language = __null,
         uint32 fingerprint = 0);
   status_t SetTo(const char* signature,
         const char* language = __null);

   status_t InitCheck() const;
   int32 CountItems() const;

protected:
        BCatalog(const BCatalog&);
   const BCatalog& operator= (const BCatalog&);


   BCatalogData* fCatalogData;
 mutable BLocker fLock;

private:
 friend class BLocale;
 friend status_t get_add_on_catalog(BCatalog*, const char*);
};
class BLayout;
class BView;


class BLayoutItem : public BArchivable {
public:
        BLayoutItem();
        BLayoutItem(BMessage* from);
 virtual ~BLayoutItem();

   BLayout* Layout() const;
   bool RemoveSelf();

 virtual BSize MinSize() = 0;
 virtual BSize MaxSize() = 0;
 virtual BSize PreferredSize() = 0;
 virtual BAlignment Alignment() = 0;

 virtual void SetExplicitMinSize(BSize size) = 0;
 virtual void SetExplicitMaxSize(BSize size) = 0;
 virtual void SetExplicitPreferredSize(BSize size) = 0;
   void SetExplicitSize(BSize size);
 virtual void SetExplicitAlignment(BAlignment alignment) = 0;

 virtual bool IsVisible() = 0;
 virtual void SetVisible(bool visible) = 0;

 virtual BRect Frame() = 0;
 virtual void SetFrame(BRect frame) = 0;

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

 virtual BView* View();

 virtual void InvalidateLayout(bool children = false);
 virtual void Relayout(bool immediate = false);

   void* LayoutData() const;
   void SetLayoutData(void* data);

   void AlignInFrame(BRect frame);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);


 virtual void LayoutInvalidated(bool children);

 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);

 virtual void AncestorVisibilityChanged(bool shown);

private:
   void SetLayout(BLayout* layout);

 virtual void _ReservedLayoutItem1();
 virtual void _ReservedLayoutItem2();
 virtual void _ReservedLayoutItem3();
 virtual void _ReservedLayoutItem4();
 virtual void _ReservedLayoutItem5();
 virtual void _ReservedLayoutItem6();
 virtual void _ReservedLayoutItem7();
 virtual void _ReservedLayoutItem8();
 virtual void _ReservedLayoutItem9();
 virtual void _ReservedLayoutItem10();


        BLayoutItem(const BLayoutItem&);
   void operator =(const BLayoutItem&);

   friend class BLayout;

   BLayout* fLayout;
   void* fLayoutData;

   uint32 _reserved[5];
};




class BLayoutContext;
class BLayoutItem;
class BView;


class BLayout : public BLayoutItem {
public:
        BLayout();
        BLayout(BMessage* archive);
 virtual ~BLayout();

   BView* Owner() const;
   BView* TargetView() const;
 virtual BView* View();


 virtual BLayoutItem* AddView(BView* child);
 virtual BLayoutItem* AddView(int32 index, BView* child);

 virtual bool AddItem(BLayoutItem* item);
 virtual bool AddItem(int32 index, BLayoutItem* item);

 virtual bool RemoveView(BView* child);
 virtual bool RemoveItem(BLayoutItem* item);
 virtual BLayoutItem* RemoveItem(int32 index);

   BLayoutItem* ItemAt(int32 index) const;
   int32 CountItems() const;
   int32 IndexOfItem(const BLayoutItem* item) const;
   int32 IndexOfView(BView* child) const;

   bool AncestorsVisible() const;



 virtual void InvalidateLayout(bool children = false);
 virtual void Relayout(bool immediate = false);

   void RequireLayout();
   bool IsValid();
   void EnableLayoutInvalidation();
   void DisableLayoutInvalidation();

   void LayoutItems(bool force = false);
   BRect LayoutArea();
   BLayoutContext* LayoutContext() const;

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* archive) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);
 virtual void LayoutInvalidated(bool children);
 virtual void DoLayout() = 0;
 virtual void OwnerChanged(BView* was);


 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);
 virtual void AncestorVisibilityChanged(bool shown);


   void VisibilityChanged(bool show);

   void ResetLayoutInvalidation();

private:


 virtual void _ReservedLayout1();
 virtual void _ReservedLayout2();
 virtual void _ReservedLayout3();
 virtual void _ReservedLayout4();
 virtual void _ReservedLayout5();
 virtual void _ReservedLayout6();
 virtual void _ReservedLayout7();
 virtual void _ReservedLayout8();
 virtual void _ReservedLayout9();
 virtual void _ReservedLayout10();


        BLayout(const BLayout&);
   void operator =(const BLayout&);

   friend class BView;

   void SetOwner(BView* owner);
   void SetTarget(BView* target);

   void _LayoutWithinContext(bool force,
         BLayoutContext* context);

   uint32 fState;
   bool fAncestorsVisible;
   int32 fInvalidationDisabled;
   BLayoutContext* fContext;
   BView* fOwner;
   BView* fTarget;
   BList fItems;
   BList fNestedLayouts;

   uint32 _reserved[10];
};







class BAbstractLayout : public BLayout {
public:
        BAbstractLayout();
        BAbstractLayout(BMessage* from);
 virtual ~BAbstractLayout();

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment Alignment();

 virtual void SetExplicitMinSize(BSize size);
 virtual void SetExplicitMaxSize(BSize size);
 virtual void SetExplicitPreferredSize(BSize size);
 virtual void SetExplicitAlignment(BAlignment alignment);

 virtual BSize BaseMinSize();
 virtual BSize BaseMaxSize();
 virtual BSize BasePreferredSize();
 virtual BAlignment BaseAlignment();

 virtual BRect Frame();
 virtual void SetFrame(BRect frame);

 virtual bool IsVisible();
 virtual void SetVisible(bool visible);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* archive) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);
 virtual void LayoutInvalidated(bool children);
 virtual void OwnerChanged(BView* was);


 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);
 virtual void AncestorVisibilityChanged(bool shown);

private:
 virtual void _ReservedAbstractLayout1();
 virtual void _ReservedAbstractLayout2();
 virtual void _ReservedAbstractLayout3();
 virtual void _ReservedAbstractLayout4();
 virtual void _ReservedAbstractLayout5();
 virtual void _ReservedAbstractLayout6();
 virtual void _ReservedAbstractLayout7();
 virtual void _ReservedAbstractLayout8();
 virtual void _ReservedAbstractLayout9();
 virtual void _ReservedAbstractLayout10();


        BAbstractLayout(const BAbstractLayout&);
   void operator =(const BAbstractLayout&);

   struct Proxy;
   struct ViewProxy;
   struct DataProxy;

   Proxy* fExplicitData;
   uint32 _reserved[4];
};

class BLayoutContext;


class BTwoDimensionalLayout : public BAbstractLayout {
public:
        BTwoDimensionalLayout();
        BTwoDimensionalLayout(BMessage* from);
 virtual ~BTwoDimensionalLayout();

   void SetInsets(float left, float top, float right,
         float bottom);
   void SetInsets(float horizontal, float vertical);
   void SetInsets(float insets);
   void GetInsets(float* left, float* top, float* right,
         float* bottom) const;

   void AlignLayoutWith(BTwoDimensionalLayout* other,
         orientation orientation);

 virtual BSize BaseMinSize();
 virtual BSize BaseMaxSize();
 virtual BSize BasePreferredSize();
 virtual BAlignment BaseAlignment();

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

 virtual void SetFrame(BRect frame);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:
   struct ColumnRowConstraints {
    float weight;
    float min;
    float max;
   };

   struct Dimensions {
    int32 x;
    int32 y;
    int32 width;
    int32 height;
   };

 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);
 virtual void LayoutInvalidated(bool children = false);

 virtual void DoLayout();

   BSize AddInsets(BSize size);
   void AddInsets(float* minHeight, float* maxHeight,
         float* preferredHeight);
   BSize SubtractInsets(BSize size);

 virtual void PrepareItems(orientation orientation);
 virtual bool HasMultiColumnItems();
 virtual bool HasMultiRowItems();

 virtual int32 InternalCountColumns() = 0;
 virtual int32 InternalCountRows() = 0;
 virtual void GetColumnRowConstraints(
         orientation orientation,
         int32 index,
         ColumnRowConstraints* constraints) = 0;
 virtual void GetItemDimensions(BLayoutItem* item,
         Dimensions* dimensions) = 0;

private:
   class CompoundLayouter;
   class LocalLayouter;
   class VerticalCompoundLayouter;

   friend class LocalLayouter;

   void _ValidateMinMax();

protected:
   float fLeftInset;
   float fRightInset;
   float fTopInset;
   float fBottomInset;
   float fHSpacing;
   float fVSpacing;

private:


 virtual void _ReservedTwoDimensionalLayout1();
 virtual void _ReservedTwoDimensionalLayout2();
 virtual void _ReservedTwoDimensionalLayout3();
 virtual void _ReservedTwoDimensionalLayout4();
 virtual void _ReservedTwoDimensionalLayout5();
 virtual void _ReservedTwoDimensionalLayout6();
 virtual void _ReservedTwoDimensionalLayout7();
 virtual void _ReservedTwoDimensionalLayout8();
 virtual void _ReservedTwoDimensionalLayout9();
 virtual void _ReservedTwoDimensionalLayout10();


        BTwoDimensionalLayout(
         const BTwoDimensionalLayout&);
   void operator =(const BTwoDimensionalLayout&);

   LocalLayouter* fLocalLayouter;

   uint32 _reserved[5];
};

class BGroupLayout : public BTwoDimensionalLayout {
public:
        BGroupLayout(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING);
        BGroupLayout(BMessage* from);
 virtual ~BGroupLayout();

   float Spacing() const;
   void SetSpacing(float spacing);

   orientation Orientation() const;
   void SetOrientation(orientation orientation);

   float ItemWeight(int32 index) const;
   void SetItemWeight(int32 index, float weight);

 virtual BLayoutItem* AddView(BView* child);
 virtual BLayoutItem* AddView(int32 index, BView* child);
 virtual BLayoutItem* AddView(BView* child, float weight);
 virtual BLayoutItem* AddView(int32 index, BView* child,
         float weight);

 virtual bool AddItem(BLayoutItem* item);
 virtual bool AddItem(int32 index, BLayoutItem* item);
 virtual bool AddItem(BLayoutItem* item, float weight);
 virtual bool AddItem(int32 index, BLayoutItem* item,
         float weight);

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);
 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);

 virtual void PrepareItems(orientation orientation);

 virtual int32 InternalCountColumns();
 virtual int32 InternalCountRows();
 virtual void GetColumnRowConstraints(
         orientation orientation,
         int32 index,
         ColumnRowConstraints* constraints);
 virtual void GetItemDimensions(BLayoutItem* item,
         Dimensions* dimensions);

private:


 virtual void _ReservedGroupLayout1();
 virtual void _ReservedGroupLayout2();
 virtual void _ReservedGroupLayout3();
 virtual void _ReservedGroupLayout4();
 virtual void _ReservedGroupLayout5();
 virtual void _ReservedGroupLayout6();
 virtual void _ReservedGroupLayout7();
 virtual void _ReservedGroupLayout8();
 virtual void _ReservedGroupLayout9();
 virtual void _ReservedGroupLayout10();


        BGroupLayout(const BGroupLayout&);
   void operator =(const BGroupLayout&);

   struct ItemLayoutData;

   ItemLayoutData* _LayoutDataForItem(BLayoutItem* item) const;

   orientation fOrientation;
   BList fVisibleItems;

   uint32 _reserved[5];
};







class BHandler;
class BLooper;
class BMessage;


class BInvoker {
public:
        BInvoker();
        BInvoker(BMessage* message,
         const BHandler* handler,
         const BLooper* looper = __null);
        BInvoker(BMessage* message, BMessenger target);
 virtual ~BInvoker();

 virtual status_t SetMessage(BMessage* message);
   BMessage* Message() const;
   uint32 Command() const;

 virtual status_t SetTarget(const BHandler* handler,
         const BLooper* looper = __null);
 virtual status_t SetTarget(BMessenger messenger);
   bool IsTargetLocal() const;
   BHandler* Target(BLooper** _looper = __null) const;
   BMessenger Messenger() const;

 virtual status_t SetHandlerForReply(BHandler* handler);
   BHandler* HandlerForReply() const;

 virtual status_t Invoke(BMessage* message = __null);
   status_t InvokeNotify(BMessage* message,
         uint32 kind = B_CONTROL_INVOKED);
   status_t SetTimeout(bigtime_t timeout);
   bigtime_t Timeout() const;

protected:
   uint32 InvokeKind(bool* _notify = __null);
   void BeginInvokeNotify(
         uint32 kind = B_CONTROL_INVOKED);
   void EndInvokeNotify();

private:
 virtual void _ReservedInvoker1();
 virtual void _ReservedInvoker2();
 virtual void _ReservedInvoker3();

        BInvoker(const BInvoker&);
   BInvoker& operator=(const BInvoker&);

   BMessage* fMessage;
   BMessenger fMessenger;
   BHandler* fReplyTo;
   bigtime_t fTimeout;
   uint32 fNotifyKind;
   uint32 _reserved[1];
};




enum {
 B_CONTROL_OFF = 0,
 B_CONTROL_ON = 1,
 B_CONTROL_PARTIALLY_ON = 2
};

class BBitmap;
class BWindow;

namespace BPrivate {
 class BIcon;
};


class BControl : public BView, public BInvoker {
public:
        BControl(BRect frame, const char* name,
         const char* label, BMessage* message,
         uint32 resizingMode, uint32 flags);
        BControl(const char* name, const char* label,
         BMessage* message, uint32 flags);
 virtual ~BControl();

        BControl(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;

 virtual void WindowActivated(bool active);

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void AllAttached();
 virtual void AllDetached();

 virtual void MessageReceived(BMessage* message);
 virtual void MakeFocus(bool focus = true);

 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);

 virtual void SetLabel(const char* string);
   const char* Label() const;

 virtual void SetValue(int32 value);
   int32 Value() const;

 virtual void SetEnabled(bool enabled);
   bool IsEnabled() const;

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual status_t Invoke(BMessage* message = __null);
 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);
 virtual status_t GetSupportedSuites(BMessage* message);

 virtual status_t Perform(perform_code d, void* arg);

 virtual status_t SetIcon(const BBitmap* bitmap,
         uint32 flags = 0);
   status_t SetIconBitmap(const BBitmap* bitmap,
         uint32 which, uint32 flags = 0);
   const BBitmap* IconBitmap(uint32 which) const;

protected:
   bool IsFocusChanging() const;
   bool IsTracking() const;
   void SetTracking(bool state);

   void SetValueNoUpdate(int32 value);

private:
   struct IconData;

private:
 virtual void _ReservedControl2();
 virtual void _ReservedControl3();
 virtual void _ReservedControl4();

   BControl& operator=(const BControl&);

   void InitData(BMessage* data = __null);

private:
   char* fLabel;
   int32 fValue;
   bool fEnabled;
   bool fFocusChanging;
   bool fTracking;
   bool fWantsNav;
   BPrivate::BIcon* fIcon;


   uint32 _reserved[2];



};
class BBitmap;
class BClipboard;
class BFile;
class BList;
class BMessageRunner;

struct text_run {
 int32 offset;
 BFont font;
 rgb_color color;
};

struct text_run_array {
 int32 count;
 text_run runs[1];
};

enum undo_state {
 B_UNDO_UNAVAILABLE,
 B_UNDO_TYPING,
 B_UNDO_CUT,
 B_UNDO_PASTE,
 B_UNDO_CLEAR,
 B_UNDO_DROP
};

namespace BPrivate {
 class TextGapBuffer;
}


class BTextView : public BView {
public:
        BTextView(BRect frame, const char* name,
         BRect textRect, uint32 resizeMask,
         uint32 flags
          = B_WILL_DRAW | B_PULSE_NEEDED);
        BTextView(BRect frame, const char* name,
         BRect textRect, const BFont* initialFont,
         const rgb_color* initialColor,
         uint32 resizeMask, uint32 flags);

        BTextView(const char* name,
         uint32 flags
          = B_WILL_DRAW | B_PULSE_NEEDED);
        BTextView(const char* name,
         const BFont* initialFont,
         const rgb_color* initialColor,
         uint32 flags);

        BTextView(BMessage* archive);

 virtual ~BTextView();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);
 virtual void WindowActivated(bool active);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void Pulse();
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void MakeFocus(bool focus = true);
 virtual void MessageReceived(BMessage* message);

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 form, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);
 virtual status_t Perform(perform_code code, void* data);

   void SetText(const char* text,
         const text_run_array* runs = __null);
   void SetText(const char* text, int32 length,
         const text_run_array* runs = __null);
   void SetText(BFile* file, int32 offset,
         int32 length,
         const text_run_array* runs = __null);

   void Insert(const char* text,
         const text_run_array* runs = __null);
   void Insert(const char* text, int32 length,
         const text_run_array* runs = __null);
   void Insert(int32 offset, const char* text,
         int32 length,
         const text_run_array* runs = __null);

   void Delete();
   void Delete(int32 startOffset, int32 endOffset);

   const char* Text() const;
   int32 TextLength() const;
   void GetText(int32 offset, int32 length,
         char* buffer) const;
   uint8 ByteAt(int32 offset) const;

   int32 CountLines() const;
   int32 CurrentLine() const;
   void GoToLine(int32 lineNumber);

 virtual void Cut(BClipboard* clipboard);
 virtual void Copy(BClipboard* clipboard);
 virtual void Paste(BClipboard* clipboard);
   void Clear();

 virtual bool AcceptsPaste(BClipboard* clipboard);
 virtual bool AcceptsDrop(const BMessage* message);

 virtual void Select(int32 startOffset, int32 endOffset);
   void SelectAll();
   void GetSelection(int32* _start, int32* _end) const;

   void SetFontAndColor(const BFont* font,
         uint32 mode = B_FONT_ALL,
         const rgb_color* color = __null);
   void SetFontAndColor(int32 startOffset,
         int32 endOffset, const BFont* font,
         uint32 mode = B_FONT_ALL,
         const rgb_color* color = __null);

   void GetFontAndColor(int32 offset, BFont* _font,
         rgb_color* _color = __null) const;
   void GetFontAndColor(BFont* _font, uint32* _mode,
         rgb_color* _color = __null,
         bool* _sameColor = __null) const;

   void SetRunArray(int32 startOffset, int32 endOffset,
         const text_run_array* runs);
   text_run_array* RunArray(int32 startOffset, int32 endOffset,
         int32* _size = __null) const;

   int32 LineAt(int32 offset) const;
   int32 LineAt(BPoint point) const;
   BPoint PointAt(int32 offset,
         float* _height = __null) const;
   int32 OffsetAt(BPoint point) const;
   int32 OffsetAt(int32 line) const;

 virtual void FindWord(int32 offset, int32* _fromOffset,
         int32* _toOffset);

 virtual bool CanEndLine(int32 offset);

   float LineWidth(int32 lineNumber = 0) const;
   float LineHeight(int32 lineNumber = 0) const;
   float TextHeight(int32 startLine,
         int32 endLine) const;

   void GetTextRegion(int32 startOffset,
         int32 endOffset, BRegion* outRegion) const;

 virtual void ScrollToOffset(int32 offset);
   void ScrollToSelection();

   void Highlight(int32 startOffset, int32 endOffset);

   void SetTextRect(BRect rect);
   BRect TextRect() const;
   void SetInsets(float left, float top, float right,
         float bottom);
   void GetInsets(float* _left, float* _top,
         float* _right, float* _bottom) const;

   void SetStylable(bool stylable);
   bool IsStylable() const;
   void SetTabWidth(float width);
   float TabWidth() const;
   void MakeSelectable(bool selectable = true);
   bool IsSelectable() const;
   void MakeEditable(bool editable = true);
   bool IsEditable() const;
   void SetWordWrap(bool wrap);
   bool DoesWordWrap() const;
   void SetMaxBytes(int32 max);
   int32 MaxBytes() const;
   void DisallowChar(uint32 character);
   void AllowChar(uint32 character);
   void SetAlignment(alignment align);
   alignment Alignment() const;
   void SetAutoindent(bool state);
   bool DoesAutoindent() const;
   void SetColorSpace(color_space colors);
   color_space ColorSpace() const;
   void MakeResizable(bool resize,
         BView* resizeView = __null);
   bool IsResizable() const;
   void SetDoesUndo(bool undo);
   bool DoesUndo() const;
   void HideTyping(bool enabled);
   bool IsTypingHidden() const;

 virtual void ResizeToPreferred();
 virtual void GetPreferredSize(float* _width, float* _height);

 virtual void AllAttached();
 virtual void AllDetached();

 static text_run_array* AllocRunArray(int32 entryCount,
         int32* outSize = __null);
 static text_run_array* CopyRunArray(const text_run_array* orig,
         int32 countDelta = 0);
 static void FreeRunArray(text_run_array* array);
 static void* FlattenRunArray(const text_run_array* runArray,
         int32* _size = __null);
 static text_run_array* UnflattenRunArray(const void* data,
         int32* _size = __null);

protected:
 virtual void InsertText(const char* text, int32 length,
         int32 offset, const text_run_array* runs);
 virtual void DeleteText(int32 fromOffset, int32 toOffset);

public:
 virtual void Undo(BClipboard* clipboard);
   undo_state UndoState(bool* isRedo) const;

protected:
 virtual void GetDragParameters(BMessage* drag,
         BBitmap** _bitmap, BPoint* point,
         BHandler** _handler);

 virtual void LayoutInvalidated(bool descendants);
 virtual void DoLayout();

public:
 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

private:

 virtual void _ReservedTextView3();
 virtual void _ReservedTextView4();
 virtual void _ReservedTextView5();
 virtual void _ReservedTextView6();
 virtual void _ReservedTextView7();
 virtual void _ReservedTextView8();
 virtual void _ReservedTextView9();
 virtual void _ReservedTextView10();
 virtual void _ReservedTextView11();
 virtual void _ReservedTextView12();

private:
   class InlineInput;
   struct LayoutData;
   class LineBuffer;
   class StyleBuffer;
   class TextTrackState;
   class UndoBuffer;


   class CutUndoBuffer;
   class PasteUndoBuffer;
   class ClearUndoBuffer;
   class DropUndoBuffer;
   class TypingUndoBuffer;

   friend class TextTrackState;

   void _InitObject(BRect textRect,
         const BFont* initialFont,
         const rgb_color* initialColor);

   void _ValidateLayoutData();
   void _ResetTextRect();

   void _HandleBackspace(int32 modifiers = -1);
   void _HandleArrowKey(uint32 arrowKey,
         int32 modifiers = -1);
   void _HandleDelete(int32 modifiers = -1);
   void _HandlePageKey(uint32 pageKey,
         int32 modifiers = -1);
   void _HandleAlphaKey(const char* bytes,
         int32 numBytes);

   void _Refresh(int32 fromOffset, int32 toOffset,
         int32 scrollTo = (-(2147483647)-1));
   void _RecalculateLineBreaks(int32* startLine,
         int32* endLine);
   void _ValidateTextRect();
   int32 _FindLineBreak(int32 fromOffset,
         float* _ascent, float* _descent,
         float* inOutWidth);

   float _StyledWidth(int32 fromOffset, int32 length,
         float* _ascent = __null,
         float* _descent = __null) const;
   float _TabExpandedStyledWidth(int32 offset,
         int32 length, float* _ascent = __null,
         float* _descent = __null) const;

   float _ActualTabWidth(float location) const;

   void _DoInsertText(const char* text, int32 length,
         int32 offset, const text_run_array* runs);

   void _DoDeleteText(int32 fromOffset,
         int32 toOffset);

   void _DrawLine(BView* view, const int32 &startLine,
         const int32& startOffset,
         const bool& erase, BRect& eraseRect,
         BRegion& inputRegion);

   void _DrawLines(int32 startLine, int32 endLine,
         int32 startOffset = -1,
         bool erase = false);
   void _RequestDrawLines(int32 startLine,
         int32 endLine);

   void _DrawCaret(int32 offset, bool visible);
   void _ShowCaret();
   void _HideCaret();
   void _InvertCaret();
   void _DragCaret(int32 offset);

   void _StopMouseTracking();
   bool _PerformMouseUp(BPoint where);
   bool _PerformMouseMoved(BPoint where, uint32 code);

   void _TrackMouse(BPoint where,
         const BMessage* message,
         bool force = false);

   void _TrackDrag(BPoint where);
   void _InitiateDrag();
   bool _MessageDropped(BMessage* message,
         BPoint where, BPoint offset);

   void _PerformAutoScrolling();
   void _UpdateScrollbars();
   void _ScrollBy(float horizontalStep,
         float verticalStep);
   void _ScrollTo(float x, float y);

   void _AutoResize(bool doRedraw = true);

   void _NewOffscreen(float padding = 0.0);
   void _DeleteOffscreen();

   void _Activate();
   void _Deactivate();

   void _NormalizeFont(BFont* font);

   void _SetRunArray(int32 startOffset, int32 endOffset,
         const text_run_array* runs);

   void _ApplyStyleRange(int32 fromOffset,
         int32 toOffset,
         uint32 mode = B_FONT_ALL,
         const BFont* font = __null,
         const rgb_color* color = __null,
         bool syncNullStyle = true);

   uint32 _CharClassification(int32 offset) const;
   int32 _NextInitialByte(int32 offset) const;
   int32 _PreviousInitialByte(int32 offset) const;

   int32 _PreviousLineStart(int32 offset);
   int32 _NextLineEnd(int32 offset);

   int32 _PreviousWordBoundary(int32 offset);
   int32 _NextWordBoundary(int32 offset);

   int32 _PreviousWordStart(int32 offset);
   int32 _NextWordEnd(int32 offset);

   bool _GetProperty(BMessage* message,
         BMessage* specifier,
         const char* property, BMessage* reply);
   bool _SetProperty(BMessage* message,
         BMessage* specifier,
         const char* property, BMessage* reply);
   bool _CountProperties(BMessage* message,
         BMessage* specifier, const char* property,
         BMessage* reply);

   void _HandleInputMethodChanged(BMessage* message);
   void _HandleInputMethodLocationRequest();
   void _CancelInputMethod();

   int32 _LineAt(int32 offset) const;
   int32 _LineAt(const BPoint& point) const;
   bool _IsOnEmptyLastLine(int32 offset) const;

   float _NullStyleHeight() const;

   void _ShowContextMenu(BPoint where);

   void _FilterDisallowedChars(char* text,
         ssize_t& length, text_run_array* runArray);

   void _UpdateInsets(const BRect& rect);

private:
   BPrivate::TextGapBuffer* fText;
   LineBuffer* fLines;
   StyleBuffer* fStyles;
   BRect fTextRect;
   int32 fSelStart;
   int32 fSelEnd;
   bool fCaretVisible;
   bigtime_t fCaretTime;
   int32 fCaretOffset;
   int32 fClickCount;
   bigtime_t fClickTime;
   int32 fDragOffset;
   uint8 fCursor;
   bool fActive;
   bool fStylable;
   float fTabWidth;
   bool fSelectable;
   bool fEditable;
   bool fWrap;
   int32 fMaxBytes;
   BList* fDisallowedChars;
   alignment fAlignment;
   bool fAutoindent;
   BBitmap* fOffscreen;
   color_space fColorSpace;
   bool fResizable;
   BView* fContainerView;
   UndoBuffer* fUndo;
   InlineInput* fInline;
   BMessageRunner* fDragRunner;
   BMessageRunner* fClickRunner;
   BPoint fWhere;
   TextTrackState* fTrackingMouse;

   float fMinTextRectWidth;
   LayoutData* fLayoutData;
   int32 fLastClickOffset;

   bool fInstalledNavigateCommandWordwiseShortcuts : 1;
   bool fInstalledNavigateOptionWordwiseShortcuts : 1;
   bool fInstalledNavigateOptionLinewiseShortcuts : 1;
   bool fInstalledNavigateHomeEndDocwiseShortcuts : 1;

   bool fInstalledSelectCommandWordwiseShortcuts : 1;
   bool fInstalledSelectOptionWordwiseShortcuts : 1;
   bool fInstalledSelectOptionLinewiseShortcuts : 1;
   bool fInstalledSelectHomeEndDocwiseShortcuts : 1;

   bool fInstalledRemoveCommandWordwiseShortcuts : 1;
   bool fInstalledRemoveOptionWordwiseShortcuts : 1;

   uint32 _reserved[6];
};


class BLayoutItem;
namespace BPrivate {
 class _BTextInput_;
}


class BTextControl : public BControl {
public:
        BTextControl(BRect frame, const char* name,
         const char* label, const char* initialText,
         BMessage* message,
         uint32 resizeMask = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BTextControl(const char* name,
         const char* label, const char* initialText,
         BMessage* message,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BTextControl(const char* label,
         const char* initialText,
         BMessage* message);
 virtual ~BTextControl();

        BTextControl(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void SetText(const char* text);
   const char* Text() const;
   int32 TextLength() const;
   void MarkAsInvalid(bool invalid);

 virtual void SetValue(int32 value);
 virtual status_t Invoke(BMessage* message = __null);

   BTextView* TextView() const;

 virtual void SetModificationMessage(BMessage* message);
   BMessage* ModificationMessage() const;

 virtual void SetAlignment(alignment label, alignment text);
   void GetAlignment(alignment* _label,
         alignment* _text) const;
 virtual void SetDivider(float position);
   float Divider() const;

 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void AttachedToWindow();
 virtual void MakeFocus(bool focus = true);
 virtual void SetEnabled(bool enable);
 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void WindowActivated(bool active);

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual void MessageReceived(BMessage* message);
 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);

 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 transit,
         const BMessage* dragMessage);
 virtual void DetachedFromWindow();

 virtual void AllAttached();
 virtual void AllDetached();
 virtual status_t GetSupportedSuites(BMessage* data);
 virtual void SetFlags(uint32 flags);

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment LayoutAlignment();

   BLayoutItem* CreateLabelLayoutItem();
   BLayoutItem* CreateTextViewLayoutItem();

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual void LayoutInvalidated(bool descendants);
 virtual void DoLayout();

 virtual status_t SetIcon(const BBitmap* icon, uint32 flags = 0);

private:

 virtual status_t Perform(perform_code d, void* arg);

 virtual void _ReservedTextControl1();
 virtual void _ReservedTextControl2();
 virtual void _ReservedTextControl3();
 virtual void _ReservedTextControl4();

   BTextControl& operator=(const BTextControl& other);

private:
 class LabelLayoutItem;
 class TextViewLayoutItem;
 struct LayoutData;

 friend class _BTextInput_;
 friend class LabelLayoutItem;
 friend class TextViewLayoutItem;

   void _CommitValue();
   void _UpdateTextViewColors(bool enable);
   void _InitData(const char* label,
         const BMessage* archive = __null);
   void _InitText(const char* initialText,
         const BMessage* archive = __null);
   void _ValidateLayout();
   void _LayoutTextView();
   void _UpdateFrame();

   void _ValidateLayoutData();

private:
   BPrivate::_BTextInput_* fText;
   BMessage* fModificationMessage;
   alignment fLabelAlign;
   float fDivider;

   LayoutData* fLayoutData;
   uint32 fLook;

   uint32 _reserved[8];
};

MainView::MainView (BRect frame)
 : BView (frame, "main View",
    B_FOLLOW_ALL_SIDES,
    B_WILL_DRAW | B_NAVIGABLE)
{
 this->SetViewColor (ui_color(B_MENU_BACKGROUND_COLOR));

 BGroupLayout* externalGroup = new BGroupLayout(B_VERTICAL);
 externalGroup->SetInsets(10, 10);

 this->SetLayout(externalGroup);

 BTextControl* postfixSymbols = new BTextControl(BRect(0, 0, 10, 10),
     "Postfix", 
               B_CATKEY((
               "Postfix symbols:"
               ), 
               "Main View"
               )
                                              , "^", 
                                                     __null
                                                         );
 postfixSymbols->ResizeToPreferred();

 BLayoutItem* layoutItem = externalGroup->AddView(postfixSymbols);
 layoutItem->SetExplicitAlignment(BAlignment(B_ALIGN_HORIZONTAL_CENTER,
               B_ALIGN_TOP));


}


MainView::~MainView ()
{

}



void MainView::AttachedToWindow()
{
   if ( Parent() )
      SetViewColor(Parent()->ViewColor());
   BView::AttachedToWindow();
}






class SourceView {
public:
 SourceView() {};
private:

};
